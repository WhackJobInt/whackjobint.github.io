{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \uf0c1 Note This site is a Work in Progress! Many functions are still not covered yet, or those that are already covered, their documentation are subject to change! AngelScript is still a work in progress, there might be more functions or changes to come! Last Update: 23.04.2024 ( Changelog ) AngelScript \uf0c1 Introduction Using AngelScript Flags/Enums Serialization Casting Syntax Highlighter Tutorials \uf0c1 Delaying Creating Contexts Repeating Calling AngelScript in Postal3Script Cache Getting Script Classes Code Examples \uf0c1 Ported AreaEvent Map Checking Stimuli Enums \uf0c1 HintIgnoreFacing_t NPC_STATE Datatypes \uf0c1 Vector QAngle AngularImpulse string (native) string_t array (native) Objects \uf0c1 Ammo_t@ CAmmoDef@ CBaseEntity@ CGameEvent@ ConVar@ CP3SObj@ CP3Weapon@ CParticleSystem@ CPhysObj@ CSoundPatch@ CTakeDamageInfo@ CWPNData@ EHANDLE HintNodeData@ KeyValues@ Global Variables \uf0c1 engine gameeventmanager gpGlobals vec3_origin vec3_angle Interfaces \uf0c1 IPostal3Script Global Functions \uf0c1 Note As of writing none of these global functions have any page, so here's all of them in one place. string formatInt(int64 val, const string&in options = \"\", uint width = 0) string formatUInt(uint64 val, const string&in options = \"\", uint width = 0) string formatFloat(double val, const string&in options = \"\", uint width = 0, uint precision = 0) int64 parseInt(const string&in, uint base = 10, uint&out byteCount = 0) uint64 parseUInt(const string&in, uint base = 10, uint&out byteCount = 0) double parseFloat(const string&in, uint&out byteCount = 0) void Wait(double flTime, int iHandle = 0) CP3SObj@ GetContextOwner() CP3SObj@ GetContextCaller() void CreateContext(string&in func, ?&in var = null, ?&in var2 = null, ?&in var3 = null, ?&in var4 = null, ?&in var5 = null, ?&in var6 = null, ?&in var7 = null, ?&in var8 = null, ?&in var9 = null, ?&in var10 = null, ?&in var11 = null, ?&in var12 = null, ?&in var13 = null, ?&in var14 = null, ?&in var15 = null) void CreateContextClass(string&in sclass, string&in func, ?&in var2 = null, ?&in var3 = null, ?&in var4 = null, ?&in var5 = null, ?&in var6 = null, ?&in var7 = null, ?&in var8 = null, ?&in var9 = null, ?&in var10 = null, ?&in var11 = null, ?&in var12 = null, ?&in var13 = null, ?&in var14 = null, ?&in var15 = null) CP3SObj@ GetPlayer() CBaseEntity@[]& FindEntsByName(string&in name) CBaseEntity@ FindEntByName(string&in name) CP3SObj@ GetEntById(int id) CAmmoDef@ GetAmmoDef() CP3SObj@ GetCrosshair(CP3SObj@ pPlayer, Vector&inout endpos) int GetAmmoIndex(string&in name) IPostal3Script@ GetScriptObj(string&in className, CP3SObj@ pOwner) int GetAmmoMaxCarry(int ammoIndex) CBaseEntity@ CreateEnt(string&in name) void Spawn(CBaseEntity@ ent) int RandomInt(int min, int max) CTakeDamageInfo@ CreateTakeDamageInfo() double RandomFloat(double min, double max) CSoundPatch@ CreateSound(CBaseEntity@ owner, string&in name) void DestroySound(CSoundPatch@ sound) bool IsSoundPlaying(CSoundPatch@ sound) void PlaySound(CSoundPatch@ sound) void FadeOutSound(CSoundPatch@ sound, double flTime) void StopSound(CSoundPatch@ sound) void FadeInSound(CSoundPatch@ sound, double flTime) void ChangeSoundVolume(CSoundPatch@ sound, double flVolume, double flTime) CParticleSystem@ CreateEffect(CBaseEntity@ owner, string&in effect, Vector&inout pos, QAngle&inout ang, double flTime) void SetSoundVolume(CSoundPatch@ sound, double flVolume) CParticleSystem@ CreateEffectAttachment(CBaseEntity@ owner, string&in effect, int attachment, double flTime) void PrecacheModel(string&in model) void PrecacheSound(string&in sound) void PrecacheScriptSound(string&in scriptsound) void PrecacheClass(string&in sclass) void PrecacheParticleSystem(string&in particle) void PrecacheMaterial(string&in material) void PrecacheDecal(string&in decal) void ListenForGameEvent(const string&in event) void PrecacheClassModel(string&in sclass, string&in model) void StopListeningForGameEvents() ConVar@ CreateCVar(const string&in name, const string&in defValue = \"\", int flags = 0, const string&in help = \"\", bool callback = false, bool reset = false) double GetCVarFloat(const string&in cvar) ConVar@ FindCVar(const string&in name) bool GetCVarBool(const string&in cvar) int GetCVarInt(const string&in cvar) string GetCVarString(const string&in cvar) void Remove(CBaseEntity@ ent) void InstallCVarCallback(const string&in name) void RemoveEnt(CBaseEntity@ ent) void AddToSensible(CBaseEntity@ ent) bool CanSeeSpot(CP3SObj@ ent, Vector pos, bool bViewCone = false) void ValidateHints() void Teleport(CBaseEntity@ ent, Vector pos) void StringToVector(Vector&inout vec, string&in str) CBaseEntity@ CreateHint() int StringToInt(string&in str) void AddHintToList(CAI_Hint@ hint, bool bDebug = false) CBaseEntity@ ToCBaseEntity(?&in var) string[]& GetTemplateData(string&in iszTemplateName) string GetTemplateDataRandom(string&in iszTemplateName) CBaseEntity@ ParseEntity(string&in pEntData) double VectorNormalize(Vector&inout vec) double DotProduct(Vector vec1, Vector vec2) void AngleVectors(QAngle ang, Vector&inout forward, Vector&inout right, Vector&inout up) double GetP3SVar(string&in conststr) bool HasP3SVar(string&in conststr) int GetP3SFactionIndex(string&in name) int GetP3SMannerIndex(string&in name) void ShowMessage(string&in msg, string&in channel) int GetP3SItemTypeIndex(string&in name) int GetLocalTime(int flag) void FadeScreen(int r, int g, int b, int alpha, double fadeTime, double holdTime, int flags) int SetState(CP3SObj@ ent, string&in state, string&in pattern) int DropToFloor(CBaseEntity@ pEntity, uint mask, CBaseEntity@ pIgnore = null) string UnicodeToANSI(string&in unicode, bool bCleanup = true) KeyValues@ CreateKeyValues(string&in name) string InitString(string&in str = \"\") bool Bitwise_AND(int org, int check) void Printf(string&in msg, ?&in var = 0, ?&in var2 = 0, ?&in var3 = 0, ?&in var4 = 0, ?&in var5 = 0, ?&in var6 = 0, ?&in var7 = 0, ?&in var8 = 0, ?&in var9 = 0, ?&in var10 = 0, ?&in var11 = 0, ?&in var12 = 0, ?&in var13 = 0, ?&in var14 = 0, ?&in var15 = 0) void Warning(string&in msg, ?&in var = 0, ?&in var2 = 0, ?&in var3 = 0, ?&in var4 = 0, ?&in var5 = 0, ?&in var6 = 0, ?&in var7 = 0, ?&in var8 = 0, ?&in var9 = 0, ?&in var10 = 0, ?&in var11 = 0, ?&in var12 = 0, ?&in var13 = 0, ?&in var14 = 0, ?&in var15 = 0) void DebugOverlay_Box(const Vector&in origin, const Vector&in mins, const Vector&in maxs, int r, int g, int b, int a, double flDuration) void DebugOverlay_BoxAngles(const Vector&in origin, const Vector&in mins, const Vector&in maxs, const QAngle&in angles, int r, int g, int b, int a, double flDuration) void ToggleFSMOverlay(CBaseEntity@ ent)","title":"Index"},{"location":"#home","text":"Note This site is a Work in Progress! Many functions are still not covered yet, or those that are already covered, their documentation are subject to change! AngelScript is still a work in progress, there might be more functions or changes to come! Last Update: 23.04.2024 ( Changelog )","title":"Home"},{"location":"#angelscript","text":"Introduction Using AngelScript Flags/Enums Serialization Casting Syntax Highlighter","title":"AngelScript"},{"location":"#tutorials","text":"Delaying Creating Contexts Repeating Calling AngelScript in Postal3Script Cache Getting Script Classes","title":"Tutorials"},{"location":"#code-examples","text":"Ported AreaEvent Map Checking Stimuli","title":"Code Examples"},{"location":"#enums","text":"HintIgnoreFacing_t NPC_STATE","title":"Enums"},{"location":"#datatypes","text":"Vector QAngle AngularImpulse string (native) string_t array (native)","title":"Datatypes"},{"location":"#objects","text":"Ammo_t@ CAmmoDef@ CBaseEntity@ CGameEvent@ ConVar@ CP3SObj@ CP3Weapon@ CParticleSystem@ CPhysObj@ CSoundPatch@ CTakeDamageInfo@ CWPNData@ EHANDLE HintNodeData@ KeyValues@","title":"Objects"},{"location":"#global-variables","text":"engine gameeventmanager gpGlobals vec3_origin vec3_angle","title":"Global Variables"},{"location":"#interfaces","text":"IPostal3Script","title":"Interfaces"},{"location":"#global-functions","text":"Note As of writing none of these global functions have any page, so here's all of them in one place. string formatInt(int64 val, const string&in options = \"\", uint width = 0) string formatUInt(uint64 val, const string&in options = \"\", uint width = 0) string formatFloat(double val, const string&in options = \"\", uint width = 0, uint precision = 0) int64 parseInt(const string&in, uint base = 10, uint&out byteCount = 0) uint64 parseUInt(const string&in, uint base = 10, uint&out byteCount = 0) double parseFloat(const string&in, uint&out byteCount = 0) void Wait(double flTime, int iHandle = 0) CP3SObj@ GetContextOwner() CP3SObj@ GetContextCaller() void CreateContext(string&in func, ?&in var = null, ?&in var2 = null, ?&in var3 = null, ?&in var4 = null, ?&in var5 = null, ?&in var6 = null, ?&in var7 = null, ?&in var8 = null, ?&in var9 = null, ?&in var10 = null, ?&in var11 = null, ?&in var12 = null, ?&in var13 = null, ?&in var14 = null, ?&in var15 = null) void CreateContextClass(string&in sclass, string&in func, ?&in var2 = null, ?&in var3 = null, ?&in var4 = null, ?&in var5 = null, ?&in var6 = null, ?&in var7 = null, ?&in var8 = null, ?&in var9 = null, ?&in var10 = null, ?&in var11 = null, ?&in var12 = null, ?&in var13 = null, ?&in var14 = null, ?&in var15 = null) CP3SObj@ GetPlayer() CBaseEntity@[]& FindEntsByName(string&in name) CBaseEntity@ FindEntByName(string&in name) CP3SObj@ GetEntById(int id) CAmmoDef@ GetAmmoDef() CP3SObj@ GetCrosshair(CP3SObj@ pPlayer, Vector&inout endpos) int GetAmmoIndex(string&in name) IPostal3Script@ GetScriptObj(string&in className, CP3SObj@ pOwner) int GetAmmoMaxCarry(int ammoIndex) CBaseEntity@ CreateEnt(string&in name) void Spawn(CBaseEntity@ ent) int RandomInt(int min, int max) CTakeDamageInfo@ CreateTakeDamageInfo() double RandomFloat(double min, double max) CSoundPatch@ CreateSound(CBaseEntity@ owner, string&in name) void DestroySound(CSoundPatch@ sound) bool IsSoundPlaying(CSoundPatch@ sound) void PlaySound(CSoundPatch@ sound) void FadeOutSound(CSoundPatch@ sound, double flTime) void StopSound(CSoundPatch@ sound) void FadeInSound(CSoundPatch@ sound, double flTime) void ChangeSoundVolume(CSoundPatch@ sound, double flVolume, double flTime) CParticleSystem@ CreateEffect(CBaseEntity@ owner, string&in effect, Vector&inout pos, QAngle&inout ang, double flTime) void SetSoundVolume(CSoundPatch@ sound, double flVolume) CParticleSystem@ CreateEffectAttachment(CBaseEntity@ owner, string&in effect, int attachment, double flTime) void PrecacheModel(string&in model) void PrecacheSound(string&in sound) void PrecacheScriptSound(string&in scriptsound) void PrecacheClass(string&in sclass) void PrecacheParticleSystem(string&in particle) void PrecacheMaterial(string&in material) void PrecacheDecal(string&in decal) void ListenForGameEvent(const string&in event) void PrecacheClassModel(string&in sclass, string&in model) void StopListeningForGameEvents() ConVar@ CreateCVar(const string&in name, const string&in defValue = \"\", int flags = 0, const string&in help = \"\", bool callback = false, bool reset = false) double GetCVarFloat(const string&in cvar) ConVar@ FindCVar(const string&in name) bool GetCVarBool(const string&in cvar) int GetCVarInt(const string&in cvar) string GetCVarString(const string&in cvar) void Remove(CBaseEntity@ ent) void InstallCVarCallback(const string&in name) void RemoveEnt(CBaseEntity@ ent) void AddToSensible(CBaseEntity@ ent) bool CanSeeSpot(CP3SObj@ ent, Vector pos, bool bViewCone = false) void ValidateHints() void Teleport(CBaseEntity@ ent, Vector pos) void StringToVector(Vector&inout vec, string&in str) CBaseEntity@ CreateHint() int StringToInt(string&in str) void AddHintToList(CAI_Hint@ hint, bool bDebug = false) CBaseEntity@ ToCBaseEntity(?&in var) string[]& GetTemplateData(string&in iszTemplateName) string GetTemplateDataRandom(string&in iszTemplateName) CBaseEntity@ ParseEntity(string&in pEntData) double VectorNormalize(Vector&inout vec) double DotProduct(Vector vec1, Vector vec2) void AngleVectors(QAngle ang, Vector&inout forward, Vector&inout right, Vector&inout up) double GetP3SVar(string&in conststr) bool HasP3SVar(string&in conststr) int GetP3SFactionIndex(string&in name) int GetP3SMannerIndex(string&in name) void ShowMessage(string&in msg, string&in channel) int GetP3SItemTypeIndex(string&in name) int GetLocalTime(int flag) void FadeScreen(int r, int g, int b, int alpha, double fadeTime, double holdTime, int flags) int SetState(CP3SObj@ ent, string&in state, string&in pattern) int DropToFloor(CBaseEntity@ pEntity, uint mask, CBaseEntity@ pIgnore = null) string UnicodeToANSI(string&in unicode, bool bCleanup = true) KeyValues@ CreateKeyValues(string&in name) string InitString(string&in str = \"\") bool Bitwise_AND(int org, int check) void Printf(string&in msg, ?&in var = 0, ?&in var2 = 0, ?&in var3 = 0, ?&in var4 = 0, ?&in var5 = 0, ?&in var6 = 0, ?&in var7 = 0, ?&in var8 = 0, ?&in var9 = 0, ?&in var10 = 0, ?&in var11 = 0, ?&in var12 = 0, ?&in var13 = 0, ?&in var14 = 0, ?&in var15 = 0) void Warning(string&in msg, ?&in var = 0, ?&in var2 = 0, ?&in var3 = 0, ?&in var4 = 0, ?&in var5 = 0, ?&in var6 = 0, ?&in var7 = 0, ?&in var8 = 0, ?&in var9 = 0, ?&in var10 = 0, ?&in var11 = 0, ?&in var12 = 0, ?&in var13 = 0, ?&in var14 = 0, ?&in var15 = 0) void DebugOverlay_Box(const Vector&in origin, const Vector&in mins, const Vector&in maxs, int r, int g, int b, int a, double flDuration) void DebugOverlay_BoxAngles(const Vector&in origin, const Vector&in mins, const Vector&in maxs, const QAngle&in angles, int r, int g, int b, int a, double flDuration) void ToggleFSMOverlay(CBaseEntity@ ent)","title":"Global Functions"},{"location":"TBD/","text":"Unfinished! \uf0c1 This page of AngelScript has not worked on yet! Sorry! We're working on it!","title":"Unfinished!"},{"location":"TBD/#unfinished","text":"This page of AngelScript has not worked on yet! Sorry! We're working on it!","title":"Unfinished!"},{"location":"casting/","text":"Casting \uf0c1 Some object types support casting, some require manual, and some is done automatically. As of writing only IPostal3Script@ and CBaseEntity@ are capable of some sort of casting. Manual Casting \uf0c1 Example(s) \uf0c1 // From CBaseEntity@ to CP3Weapon@ CBaseEntity@ pointer; CP3Weapon@ pWpn = cast<CP3Weapon@>(pointer); // From IPostal3Script@ to MyClass@ class MyClass : IPostal3Script { // Content here... ... } MyClass@ ToMyClass(CP3SObj@ ptr) { IPostal3Script@ class = GetScriptObj(\"MyClass\", ptr); if (@class == null) return null; return cast<MyClass@>(class); } // Rough example of how this would look like... void SomeFunction() { CP3SObj@ self; if (@self == null) return; MyClass@ class = ToMyClass(self); if (@class == null) return; ... } From To Note(s) IPostal3Script@ [class]@ Script module, class CBaseEntity@ CParticleSystem@ n/a CBaseEntity@ CP3SObj@ n/a CBaseEntity@ CP3Weapon@ n/a CBaseEntity@ CP3Player@ n/a CBaseEntity@ CAI_Hint@ n/a Auto/Implicit Casting \uf0c1 The objects below also support manual casting, but normally unnecessary. Example(s) \uf0c1 // CBaseEntity@ to EHANDLE and vice versa EHANDLE handle; CBaseEntity@ pointer = handle; EHANDLE newHandle = pointer; // CP3Player@ to CBaseEntity@ CP3Player@ pPlayer; CBaseEntity@ pEnt = pPlayer; // CP3Weapon@ to CBaseEntity@ CP3Weapon@ wep; CBaseEntity@ ent = wep; From To Note(s) string_t string n/a string string_t n/a EHANDLE CBaseEntity@ n/a CBaseEntity@ EHANDLE n/a CParticleSystem@ CBaseEntity@ n/a CP3Weapon@ CBaseEntity@ n/a CP3Player@ CBaseEntity@ n/a CAI_Hint@ CBaseEntity@ n/a","title":"Casting"},{"location":"casting/#casting","text":"Some object types support casting, some require manual, and some is done automatically. As of writing only IPostal3Script@ and CBaseEntity@ are capable of some sort of casting.","title":"Casting"},{"location":"casting/#manual-casting","text":"","title":"Manual Casting"},{"location":"casting/#examples","text":"// From CBaseEntity@ to CP3Weapon@ CBaseEntity@ pointer; CP3Weapon@ pWpn = cast<CP3Weapon@>(pointer); // From IPostal3Script@ to MyClass@ class MyClass : IPostal3Script { // Content here... ... } MyClass@ ToMyClass(CP3SObj@ ptr) { IPostal3Script@ class = GetScriptObj(\"MyClass\", ptr); if (@class == null) return null; return cast<MyClass@>(class); } // Rough example of how this would look like... void SomeFunction() { CP3SObj@ self; if (@self == null) return; MyClass@ class = ToMyClass(self); if (@class == null) return; ... } From To Note(s) IPostal3Script@ [class]@ Script module, class CBaseEntity@ CParticleSystem@ n/a CBaseEntity@ CP3SObj@ n/a CBaseEntity@ CP3Weapon@ n/a CBaseEntity@ CP3Player@ n/a CBaseEntity@ CAI_Hint@ n/a","title":"Example(s)"},{"location":"casting/#autoimplicit-casting","text":"The objects below also support manual casting, but normally unnecessary.","title":"Auto/Implicit Casting"},{"location":"casting/#examples_1","text":"// CBaseEntity@ to EHANDLE and vice versa EHANDLE handle; CBaseEntity@ pointer = handle; EHANDLE newHandle = pointer; // CP3Player@ to CBaseEntity@ CP3Player@ pPlayer; CBaseEntity@ pEnt = pPlayer; // CP3Weapon@ to CBaseEntity@ CP3Weapon@ wep; CBaseEntity@ ent = wep; From To Note(s) string_t string n/a string string_t n/a EHANDLE CBaseEntity@ n/a CBaseEntity@ EHANDLE n/a CParticleSystem@ CBaseEntity@ n/a CP3Weapon@ CBaseEntity@ n/a CP3Player@ CBaseEntity@ n/a CAI_Hint@ CBaseEntity@ n/a","title":"Example(s)"},{"location":"changelog/","text":"Changelog \uf0c1 This is the changelog for AngelScript Docs. 23.04.2024 \uf0c1 Added Getting Started tutorial 20.03.2024 \uf0c1 Up to date 01.08.2023 \uf0c1 Updated the main pages 23.05.2023 \uf0c1 No new methods, global functions or etc. were added, AngelScript is still rapidly changing. Added Script class tutorial Updated stats Updated Creating Contexts tutorial 07.04.2023 \uf0c1 Added more flags Added Cache tutorial Added 3 more object types (CParticleSystem@, CSoundPatch@, CRProp@) Updated CP3SObj@, CBaseEntity@ with new methods Added new global functions Some functions and methods now have proper variable declarations if they didn't before 17.03.2023 \uf0c1 Added example code Updated index 16.03.2023 \uf0c1 Added new P3S->AS functions (CP3SObj@, Global functions, engine) Added Flags/Enums page Added new debugging cvar Added new hardcoded AS calls 08.02.2023 \uf0c1 Added and documented all objects and datatypes Added tutorials 03.02.2023 \uf0c1 Initial work on AngelScript docs has began","title":"Changelog"},{"location":"changelog/#changelog","text":"This is the changelog for AngelScript Docs.","title":"Changelog"},{"location":"changelog/#23042024","text":"Added Getting Started tutorial","title":"23.04.2024"},{"location":"changelog/#20032024","text":"Up to date","title":"20.03.2024"},{"location":"changelog/#01082023","text":"Updated the main pages","title":"01.08.2023"},{"location":"changelog/#23052023","text":"No new methods, global functions or etc. were added, AngelScript is still rapidly changing. Added Script class tutorial Updated stats Updated Creating Contexts tutorial","title":"23.05.2023"},{"location":"changelog/#07042023","text":"Added more flags Added Cache tutorial Added 3 more object types (CParticleSystem@, CSoundPatch@, CRProp@) Updated CP3SObj@, CBaseEntity@ with new methods Added new global functions Some functions and methods now have proper variable declarations if they didn't before","title":"07.04.2023"},{"location":"changelog/#17032023","text":"Added example code Updated index","title":"17.03.2023"},{"location":"changelog/#16032023","text":"Added new P3S->AS functions (CP3SObj@, Global functions, engine) Added Flags/Enums page Added new debugging cvar Added new hardcoded AS calls","title":"16.03.2023"},{"location":"changelog/#08022023","text":"Added and documented all objects and datatypes Added tutorials","title":"08.02.2023"},{"location":"changelog/#03022023","text":"Initial work on AngelScript docs has began","title":"03.02.2023"},{"location":"flags/","text":"Flags/Enums \uf0c1 Flags/Enums to use with functions. Note Some of these enums will be hardcoded onto AngelScript in the future GetCurLoadType \uf0c1 shared enum MapLoadType_t { MapLoad_NewGame = 0, MapLoad_LoadGame, MapLoad_Transition, MapLoad_Background } Wait \uf0c1 shared enum WaitHandle_t { WH_NOTHING = 0, // Nothing, context executes like normal (AngelScript defaults to this) WH_ABORT_MAPNAME = 1, // Context will abort if map name doesn't match before execution WH_ABORT_LEVELCHANGE = 2, // Context will immediately abort if a level change was detected WH_ABORT_SAVEGAME = 4, // Context will immediately abort if game was loaded via a save file WH_ABORT_INVALIDOWNER = 8, // Context will abort if Owner is invalid/garbage before execution WH_FREEZE_MAPNAME = 16 // Context will be forever frozen until Player reenters the same level } Relationship \uf0c1 shared enum Disposition_t { D_ER, // Undefined - error D_HT, // Hate D_FR, // Fear D_LI, // Like D_NU // Neutral } Weapon ID \uf0c1 shared enum WeaponID_t { P3_WEAPON_WRONG = -1, P3_WEAPON_DISABLED = 0, P3_WEAPON_EMPTYHANDS = 1, P3_WEAPON_WOLVERINE = 2, P3_WEAPON_NAILBAT = 3, P3_WEAPON_GRENADE = 4, P3_WEAPON_DESERT_EAGLE = 5, P3_WEAPON_TASER = 6, P3_WEAPON_SHOTGUN = 7, // auto shotgun P3_WEAPON_M60 = 8, P3_WEAPON_M16 = 9, P3_WEAPON_CAT = 10, P3_WEAPON_MACHETE = 11, P3_WEAPON_SHOVEL = 12, P3_WEAPON_MOLOTOV = 13, P3_WEAPON_GASOLINE = 14, P3_WEAPON_CATNIP = 15, P3_WEAPON_BANNER = 16, P3_WEAPON_BEENEST = 17, P3_WEAPON_COP_BATON = 18, P3_WEAPON_KROTCHY_GRENADE = 19, P3_WEAPON_HAMMER = 20, P3_WEAPON_LASERPEN = 21, P3_WEAPON_MATCH = 22, P3_WEAPON_MAXEL_SNIPER = 23, // doesn't exist P3_WEAPON_METABULKY = 24, // unused P3_WEAPON_METAONEHANDLED = 25, P3_WEAPON_METATWOHANDLED = 26, // unused P3_WEAPON_MONKEY = 27, P3_WEAPON_PHOTOCAM = 28, P3_WEAPON_SEED = 29, // unused P3_WEAPON_SHOPVAC = 30, P3_WEAPON_SPRAY = 31, P3_WEAPON_TVCAM = 32, P3_WEAPON_WEEMOTE = 33, P3_WEAPON_M136 = 34, P3_WEAPON_FIREAXE = 35, P3_WEAPON_GAMAMET = 36, P3_WEAPON_COUNT }; Weapon Type \uf0c1 shared enum WeaponType_t { WPN_TYPE_FLESH = -1, WPN_TYPE_NONE = 0, WPN_TYPE_ANIMAL, WPN_TYPE_GADGET, WPN_TYPE_NONLETHAL_MELEE, WPN_TYPE_NONLETHAL_RANGED, WPN_TYPE_MELEE, WPN_TYPE_RANGED, WPN_TYPE_BIGGUN, WPN_TYPE_SIZE }; Say \uf0c1 shared enum SentencePriority_t { SENTENCE_PRIORITY_INVALID = -1, SENTENCE_PRIORITY_NORMAL = 0, SENTENCE_PRIORITY_MEDIUM = 1, SENTENCE_PRIORITY_HIGH = 2 }; Sequence \uf0c1 shared enum Sequence_t { SEQUENCE_NONE = 0, SEQUENCE_AIM = 1, SEQUENCE_NO_ACTION_CHECK = 2 }; Inventory \uf0c1 shared enum Inventory_t { INV_SELECT = 0, INV_EQUIP = 1, INV_ADD = 2, INV_REMOVE = 3 }; Movement Type \uf0c1 shared enum P3AI_MovementType_t { AIMT_CURRENT, AIMT_WALK, AIMT_RUN, AIMT_MIX, AIMT_FLY, AIMT_RANDOM, AIMT_OFF, AIMT_TELEPORT }; Face Type \uf0c1 shared enum P3AI_FaceType_t { AIFT_FACE_NONE, AIFT_FACE_TO_TARGET, AIFT_FACE_FROM_TARGET, AIFT_FACE_AS_TARGET }; Move To Target \uf0c1 shared enum P3AI_MoveToTarget_Flags { AIMTF_NONE = 0x0000, AIMTF_ACCURATE_POSITIONING = 0x0001 }; Local Time \uf0c1 shared enum LocalTime_t { LT_YEAR = 0, // Local year LT_MONTH, // Local month LT_DAY, // Local day LT_HOURS, // Local hours LT_MINUTES, // Local minutes LT_SECONDS, // Local seconds LT_DAYS_JANUARY, // Days since January (0,365) LT_DAYS,SUNDAY, // Days since Sunday (0,6) LT_FLAG // daylight savings time flag }; Fade Flags \uf0c1 shared enum FadeFlags_t { FFADE_IN = 0x0001, FFADE_OUT = 0x0002, FFADE_MODULATE = 0x0004, FFADE_STAYOUT = 0x0008, FFADE_PURGE = 0x0010 }; Sub Flags \uf0c1 shared enum SubFlags_t { SUB_Remove = 0, SUB_DoNothing, SUB_StartFadeOut, SUB_FadeOut, SUB_Vanish, SUB_CallUseToggle, SUB_PerformFadeOut }; Collision Groups \uf0c1 shared enum Collision_Group_t { COLLISION_GROUP_NONE = 0, COLLISION_GROUP_DEBRIS, // Collides with nothing but world and static stuff COLLISION_GROUP_DEBRIS_TRIGGER, // Same as debris, but hits triggers COLLISION_GROUP_INTERACTIVE_DEBRIS, // Collides with everything except other interactive debris or debris COLLISION_GROUP_INTERACTIVE, // Collides with everything except interactive debris or debris COLLISION_GROUP_PLAYER, COLLISION_GROUP_BREAKABLE_GLASS, COLLISION_GROUP_VEHICLE, COLLISION_GROUP_PLAYER_MOVEMENT, // For HL2, same as Collision_Group_Player, for // TF2, this filters out other players and CBaseObjects COLLISION_GROUP_NPC, // Generic NPC group COLLISION_GROUP_IN_VEHICLE, // for any entity inside a vehicle COLLISION_GROUP_WEAPON, // for any weapons that need collision detection COLLISION_GROUP_VEHICLE_CLIP, // vehicle clip brush to restrict vehicle movement COLLISION_GROUP_PROJECTILE, // Projectiles! COLLISION_GROUP_DOOR_BLOCKER, // Blocks entities not permitted to get near moving doors COLLISION_GROUP_PASSABLE_DOOR, // Doors that the player shouldn't collide with COLLISION_GROUP_DISSOLVING, // Things that are dissolving are in this group COLLISION_GROUP_PUSHAWAY, // Nonsolid on client and server, pushaway in player code COLLISION_GROUP_NPC_ACTOR, // Used so NPCs in scripts ignore the player. COLLISION_GROUP_NPC_SCRIPTED, // USed for NPCs in scripts that should not collide with each other COLLISION_GROUP_AREAGROUP_VOLUME, COLLISION_GROUP_RAGDOLL, // Collides with everything except NPC, player and vehicle COLLISION_GROUP_BREAKABLE_BY_VEHICLE, COLLISION_GROUP_NOTHING, LAST_SHARED_COLLISION_GROUP }; Solid Flags \uf0c1 shared enum SolidFlags_t { FSOLID_CUSTOMRAYTEST = 0x0001, // Ignore solid type + always call into the entity for ray tests FSOLID_CUSTOMBOXTEST = 0x0002, // Ignore solid type + always call into the entity for swept box tests FSOLID_NOT_SOLID = 0x0004, // Are we currently not solid? FSOLID_TRIGGER = 0x0008, // This is something may be collideable but fires touch functions // even when it's not collideable (when the FSOLID_NOT_SOLID flag is set) FSOLID_NOT_STANDABLE = 0x0010, // You can't stand on this FSOLID_VOLUME_CONTENTS = 0x0020, // Contains volumetric contents (like water) FSOLID_FORCE_WORLD_ALIGNED = 0x0040, // Forces the collision rep to be world-aligned even if it's SOLID_BSP or SOLID_VPHYSICS FSOLID_USE_TRIGGER_BOUNDS = 0x0080, // Uses a special trigger bounds separate from the normal OBB FSOLID_ROOT_PARENT_ALIGNED = 0x0100, // Collisions are defined in root parent's local coordinate space FSOLID_TRIGGER_TOUCH_DEBRIS = 0x0200, // This trigger will touch debris objects FSOLID_PROHIBITED_AREA = 0x0400, // Prohibited areas FSOLID_MAX_BITS = 11 }; Solid types \uf0c1 shared enum SolidType_t { SOLID_NONE = 0, // no solid model SOLID_BSP = 1, // a BSP tree SOLID_BBOX = 2, // an AABB SOLID_OBB = 3, // an OBB (not implemented yet) SOLID_OBB_YAW = 4, // an OBB, constrained so that it can only yaw SOLID_CUSTOM = 5, // Always call into the entity for tests SOLID_VPHYSICS = 6, // solid vphysics object, get vcollide from the model and collide with that SOLID_SPHERE = 7, // an sphere SOLID_LAST, }; Entity Effects \uf0c1 shared enum EntityEffect_t { EF_BONEMERGE = 0x001, // Performs bone merge on client side EF_BRIGHTLIGHT = 0x002, // DLIGHT centered at entity origin EF_DIMLIGHT = 0x004, // player flashlight EF_NOINTERP = 0x008, // don't interpolate the next frame EF_NOSHADOW = 0x010, // Don't cast no shadow EF_NODRAW = 0x020, // don't draw entity EF_NORECEIVESHADOW = 0x040, // Don't receive no shadow EF_BONEMERGE_FASTCULL = 0x080, // For use with EF_BONEMERGE. If this is set, then it places this ent's origin at its // parent and uses the parent's bbox + the max extents of the aiment. // Otherwise, it sets up the parent's bones every frame to figure out where to place // the aiment, which is inefficient because it'll setup the parent's bones even if // the parent is not in the PVS. EF_ITEM_BLINK = 0x100, // blink an item so that the user notices it. EF_PARENT_ANIMATES = 0x200, // always assume that the parent entity is animating EF_MIRROR_WEAPON = 0x400, EF_MAX_BITS = 11 }; Cvar flags \uf0c1 shared enum FCVAR_t { FCVAR_NONE = 0, FCVAR_UNREGISTERED = (1<<0), FCVAR_DEVELOPMENTONLY = (1<<1), FCVAR_GAMEDLL = (1<<2), FCVAR_CLIENTDLL = (1<<3), FCVAR_HIDDEN = (1<<4), FCVAR_PROTECTED = (1<<5), FCVAR_SPONLY = (1<<6), FCVAR_ARCHIVE = (1<<7), FCVAR_NOTIFY = (1<<8), FCVAR_USERINFO = (1<<9), FCVAR_CHEAT = (1<<14), FCVAR_PRINTABLEONLY = (1<<10), FCVAR_UNLOGGED = (1<<11), FCVAR_NEVER_AS_STRING = (1<<12), FCVAR_REPLICATED = (1<<13), FCVAR_DEMO = (1<<16), FCVAR_DONTRECORD = (1<<17), FCVAR_RELOAD_MATERIALS = (1<<20), FCVAR_RELOAD_TEXTURES = (1<<21), FCVAR_NOT_CONNECTED = (1<<22), FCVAR_MATERIAL_SYSTEM_THREAD = (1<<23), FCVAR_ARCHIVE_XBOX = (1<<24), FCVAR_ACCESSIBLE_FROM_THREADS = (1<<25), FCVAR_SERVER_CAN_EXECUTE = (1<<28), FCVAR_SERVER_CANNOT_QUERY = (1<<29), FCVAR_CLIENTCMD_CAN_EXECUTE = (1<<30), FCVAR_MATERIAL_THREAD_MASK = ( FCVAR_RELOAD_MATERIALS | FCVAR_RELOAD_TEXTURES | FCVAR_MATERIAL_SYSTEM_THREAD ) }; Take damage flags \uf0c1 shared enum Damage_t { DMG_GENERIC = 0, // generic damage -- do not use if you want players to flinch and bleed! DMG_CRUSH = (1 << 0), // crushed by falling or moving object. // NOTE: It's assumed crush damage is occurring as a result of physics collision, so no extra physics force is generated by crush damage. // DON'T use DMG_CRUSH when damaging entities unless it's the result of a physics collision. You probably want DMG_CLUB instead. DMG_BULLET = (1 << 1), // shot DMG_SLASH = (1 << 2), // cut, clawed, stabbed DMG_BURN = (1 << 3), // heat burned DMG_VEHICLE = (1 << 4), // hit by a vehicle DMG_FALL = (1 << 5), // fell too far DMG_BLAST = (1 << 6), // explosive blast damage DMG_CLUB = (1 << 7), // crowbar, punch, headbutt DMG_SHOCK = (1 << 8), // electric shock DMG_SONIC = (1 << 9), // sound pulse shockwave DMG_ENERGYBEAM = (1 << 10), // laser or other high energy beam DMG_PREVENT_PHYSICS_FORCE = (1 << 11), // Prevent a physics force DMG_NEVERGIB = (1 << 12), // with this bit OR'd in, no damage type will be able to gib victims upon death DMG_ALWAYSGIB = (1 << 13), // with this bit OR'd in, any damage type can be made to gib victims upon death. DMG_DROWN = (1 << 14), // Drowning DMG_PARALYZE = (1 << 15), // slows affected creature down DMG_NERVEGAS = (1 << 16), // nerve toxins, very bad DMG_POISON = (1 << 17), // blood poisoning - heals over time like drowning damage DMG_RADIATION = (1 << 18), // radiation exposure DMG_DROWNRECOVER = (1 << 19), // drowning recovery DMG_ACID = (1 << 20), // toxic chemicals or acid burns DMG_SLOWBURN = (1 << 21), // in an oven DMG_REMOVENORAGDOLL = (1<<22), // with this bit OR'd in, no ragdoll will be created, and the target will be quietly removed. // use this to kill an entity that you've already got a server-side ragdoll for DMG_PHYSGUN = (1<<23), // Hit by manipulator. Usually doesn't do any damage. DMG_PLASMA = (1<<24), // Shot by Cremator DMG_AIRBOAT = (1<<25), // Hit by the airboat's gun DMG_DISSOLVE = (1<<26), // Dissolving! DMG_BLAST_SURFACE = (1<<27), // A blast on the surface of water that cannot harm things underwater DMG_DIRECT = (1<<28), DMG_BUCKSHOT = (1<<29), // not quite a bullet. Little, rounder, different. DMG_KNUCKLE = (DMG_DIRECT | DMG_CLUB | DMG_NEVERGIB), DMG_KICK = (DMG_KNUCKLE | DMG_REMOVENORAGDOLL), DMG_BATON = (DMG_DIRECT | DMG_FALL | DMG_CLUB), DMG_SHOVEL = (DMG_DIRECT | DMG_SLASH), DMG_SHOVEL2 = (DMG_DIRECT | DMG_SLASH | DMG_CLUB), DMG_HAMMER = (DMG_DIRECT | DMG_VEHICLE | DMG_CLUB), DMG_NAILBAT = (DMG_DIRECT | DMG_VEHICLE | DMG_CLUB | DMG_BULLET) } Entity Flags \uf0c1 shared enum EntFlags_t { FL_ONGROUND = (1<<0), // At rest / on the ground FL_DUCKING = (1<<1), // Player flag -- Player is fully crouched FL_WATERJUMP = (1<<2), // player jumping out of water FL_ONTRAIN = (1<<3), // Player is _controlling_ a train, so movement commands should be ignored on client during prediction. FL_INRAIN = (1<<4), // Indicates the entity is standing in rain FL_FROZEN = (1<<5), // Player is frozen for 3rd person camera FL_ATCONTROLS = (1<<6), // Player can't move, but keeps key inputs for controlling another entity FL_CLIENT = (1<<7), // Is a player FL_FAKECLIENT = (1<<8), // Fake client, simulated server side; don't send network messages to them // NON-PLAYER SPECIFIC = (i.e., not used by GameMovement or the client .dll ), -- Can still be applied to players, though FL_INWATER = (1<<9), // In water FL_FLY = (1<<10), // Changes the SV_Movestep= (), behavior to not need to be on ground FL_SWIM = (1<<11), // Changes the SV_Movestep= (), behavior to not need to be on ground = (but stay in water), FL_CONVEYOR = (1<<12), FL_NPC = (1<<13), FL_GODMODE = (1<<14), FL_NOTARGET = (1<<15), FL_AIMTARGET = (1<<16), // set if the crosshair needs to aim onto the entity FL_PARTIALGROUND = (1<<17), // not all corners are valid FL_STATICPROP = (1<<18), // Eetsa static prop! FL_GRAPHED = (1<<19), // worldgraph has this ent listed as something that blocks a connection FL_GRENADE = (1<<20), FL_STEPMOVEMENT = (1<<21), // Changes the SV_Movestep= (), behavior to not do any processing FL_DONTTOUCH = (1<<22), // Doesn't generate touch functions, generates Untouch= (), for anything it was touching when this flag was set FL_BASEVELOCITY = (1<<23), // Base velocity has been applied this frame = (used to convert base velocity into momentum), FL_WORLDBRUSH = (1<<24), // Not moveable/removeable brush entity = (really part of the world, but represented as an entity for transparency or something), FL_OBJECT = (1<<25), // Terrible name. This is an object that NPCs should see. Missiles, for example. FL_KILLME = (1<<26), // This entity is marked for death -- will be freed by game DLL FL_ONFIRE = (1<<27), // You know... FL_DISSOLVING = (1<<28), // We're dissolving! FL_TRANSRAGDOLL = (1<<29), // In the process of turning into a client side ragdoll. FL_UNBLOCKABLE_BY_PLAYER = (1<<30), // pusher that can't be blocked by the player FL_JUMPING = (1<<31) // player jumping } BSP Flags \uf0c1 shared enum BSPFlags_t { // lower bits are stronger, and will eat weaker brushes completely CONTENTS_EMPTY = 0, // No contents CONTENTS_SOLID = 0x1, // an eye is never valid in a solid CONTENTS_WINDOW = 0x2, // translucent, but not watery (glass) CONTENTS_AUX = 0x4, CONTENTS_GRATE = 0x8, // alpha-tested \"grate\" textures. Bullets/sight pass through, but solids don't CONTENTS_SLIME = 0x10, CONTENTS_WATER = 0x20, CONTENTS_BLOCKLOS = 0x40, // block AI line of sight CONTENTS_OPAQUE = 0x80, // things that cannot be seen through (may be non-solid though) LAST_VISIBLE_CONTENTS = 0x80, ALL_VISIBLE_CONTENTS = (LAST_VISIBLE_CONTENTS | (LAST_VISIBLE_CONTENTS-1)), CONTENTS_TESTFOGVOLUME = 0x100, CONTENTS_UNUSED = 0x200, // unused // NOTE: If it's visible, grab from the top + update LAST_VISIBLE_CONTENTS // if not visible, then grab from the bottom. CONTENTS_UNUSED6 = 0x400, CONTENTS_TEAM1 = 0x800, // per team contents used to differentiate collisions CONTENTS_TEAM2 = 0x1000, // between players and objects on different teams CONTENTS_IGNORE_NODRAW_OPAQUE = 0x2000, // ignore CONTENTS_OPAQUE on surfaces that have SURF_NODRAW CONTENTS_MOVEABLE = 0x4000, // hits entities which are MOVETYPE_PUSH (doors, plats, etc.) CONTENTS_AREAPORTAL = 0x8000, CONTENTS_PLAYERCLIP = 0x10000, CONTENTS_MONSTERCLIP = 0x20000, CONTENTS_CURRENT_0 = 0x40000, CONTENTS_CURRENT_90 = 0x80000, CONTENTS_CURRENT_180 = 0x100000, CONTENTS_CURRENT_270 = 0x200000, CONTENTS_CURRENT_UP = 0x400000, CONTENTS_CURRENT_DOWN = 0x800000, CONTENTS_ORIGIN = 0x1000000, CONTENTS_MONSTER = 0x2000000, CONTENTS_DEBRIS = 0x4000000, CONTENTS_DETAIL = 0x8000000, CONTENTS_TRANSLUCENT = 0x10000000, CONTENTS_LADDER = 0x20000000, CONTENTS_HITBOX = 0x40000000, SURF_LIGHT = 0x0001, SURF_SKY2D = 0x0002, SURF_SKY = 0x0004, SURF_WARP = 0x0008, SURF_TRANS = 0x0010, SURF_NOPORTAL = 0x0020, SURF_TRIGGER = 0x0040, SURF_NODRAW = 0x0080, SURF_HINT = 0x0100, SURF_SKIP = 0x0200, SURF_NOLIGHT = 0x0400, SURF_BUMPLIGHT = 0x0800, SURF_NOSHADOWS = 0x1000, SURF_NODECALS = 0x2000, SURF_NOCHOP = 0x4000, SURF_HITBOX = 0x8000, // ----------------------------------------------------- // spatial content masks - used for spatial queries (traceline,etc.) // ----------------------------------------------------- MASK_ALL = (0xFFFFFFFF), MASK_SOLID = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE), // everything that blocks player movement MASK_PLAYERSOLID = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE), // blocks npc movement MASK_NPCSOLID = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE), // water physics in these contents MASK_WATER = (CONTENTS_WATER|CONTENTS_MOVEABLE|CONTENTS_SLIME), // everything that blocks lighting MASK_OPAQUE = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_OPAQUE), // everything that blocks lighting, but with monsters added. MASK_OPAQUE_AND_NPCS = (MASK_OPAQUE|CONTENTS_MONSTER), // everything that blocks line of sight for AI MASK_BLOCKLOS = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_BLOCKLOS), // everything that blocks line of sight for AI plus NPCs MASK_BLOCKLOS_AND_NPCS = (MASK_BLOCKLOS|CONTENTS_MONSTER), // everything that blocks line of sight for players MASK_VISIBLE = (MASK_OPAQUE|CONTENTS_IGNORE_NODRAW_OPAQUE), // everything that blocks line of sight for players, but with monsters added. MASK_VISIBLE_AND_NPCS = (MASK_OPAQUE_AND_NPCS|CONTENTS_IGNORE_NODRAW_OPAQUE), // bullets see these as solid MASK_SHOT = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX), // non-raycasted weapons see this as solid = (includes grates), MASK_SHOT_HULL = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE), // hits solids = (not grates), and passes through everything else MASK_SHOT_PORTAL = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER), // everything normally solid, except monsters = (world+brush only), MASK_SOLID_BRUSHONLY = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_GRATE), // everything normally solid for player movement, except monsters = (world+brush only), MASK_PLAYERSOLID_BRUSHONLY = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_PLAYERCLIP|CONTENTS_GRATE), // everything normally solid for npc movement, except monsters = (world+brush only), MASK_NPCSOLID_BRUSHONLY = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE), // just the world, used for route rebuilding MASK_NPCWORLDSTATIC = (CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE), // These are things that can split areaportals MASK_SPLITAREAPORTAL = (CONTENTS_WATER|CONTENTS_SLIME), // UNDONE: This is untested, any moving water MASK_CURRENT = (CONTENTS_CURRENT_0|CONTENTS_CURRENT_90|CONTENTS_CURRENT_180|CONTENTS_CURRENT_270|CONTENTS_CURRENT_UP|CONTENTS_CURRENT_DOWN), // everything that blocks corpse movement // UNDONE: Not used yet / may be deleted MASK_DEADSOLID = (CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_GRATE), } Spawn flags \uf0c1 shared enum SpawnFlags_t { SF_NPC_WAIT_TILL_SEEN = ( 1 << 0 ), // spawnflag that makes npcs wait until player can see them before attacking. SF_NPC_GAG = ( 1 << 1 ), // no idle noises from this npc SF_NPC_FALL_TO_GROUND = ( 1 << 2 ), // used my NPC_Maker SF_NPC_DROP_HEALTHKIT = ( 1 << 3 ), // Drop a healthkit upon death SF_NPC_START_EFFICIENT = ( 1 << 4 ), // Set into efficiency mode from spawn // = ( 1 << 5 ), // = ( 1 << 6 ), SF_NPC_WAIT_FOR_SCRIPT = ( 1 << 7 ), // spawnflag that makes npcs wait to check for attacking until the script is done or they've been attacked SF_NPC_LONG_RANGE = ( 1 << 8 ), // makes npcs look far and relaxes weapon range limit SF_NPC_FADE_CORPSE = ( 1 << 9 ), // Fade out corpse after death SF_NPC_ALWAYSTHINK = ( 1 << 10 ), // Simulate even when player isn't in PVS. SF_NPC_TEMPLATE = ( 1 << 11 ), // This NPC will be used as a template by an npc_maker -- do not spawn. SF_NPC_ALTCOLLISION = ( 1 << 12 ), SF_NPC_NO_WEAPON_DROP = ( 1 << 13 ), // This NPC will not actually drop a weapon that can be picked up SF_NPC_NO_PLAYER_PUSHAWAY = ( 1 << 14 ), // = ( 1 << 15 ), // !! Flags above = ( 1 << 15 ), are reserved for NPC sub-classes SF_NPC_INTERACTABLE = (1<<30), }","title":"Flags/Enums"},{"location":"flags/#flagsenums","text":"Flags/Enums to use with functions. Note Some of these enums will be hardcoded onto AngelScript in the future","title":"Flags/Enums"},{"location":"flags/#getcurloadtype","text":"shared enum MapLoadType_t { MapLoad_NewGame = 0, MapLoad_LoadGame, MapLoad_Transition, MapLoad_Background }","title":"GetCurLoadType"},{"location":"flags/#wait","text":"shared enum WaitHandle_t { WH_NOTHING = 0, // Nothing, context executes like normal (AngelScript defaults to this) WH_ABORT_MAPNAME = 1, // Context will abort if map name doesn't match before execution WH_ABORT_LEVELCHANGE = 2, // Context will immediately abort if a level change was detected WH_ABORT_SAVEGAME = 4, // Context will immediately abort if game was loaded via a save file WH_ABORT_INVALIDOWNER = 8, // Context will abort if Owner is invalid/garbage before execution WH_FREEZE_MAPNAME = 16 // Context will be forever frozen until Player reenters the same level }","title":"Wait"},{"location":"flags/#relationship","text":"shared enum Disposition_t { D_ER, // Undefined - error D_HT, // Hate D_FR, // Fear D_LI, // Like D_NU // Neutral }","title":"Relationship"},{"location":"flags/#weapon-id","text":"shared enum WeaponID_t { P3_WEAPON_WRONG = -1, P3_WEAPON_DISABLED = 0, P3_WEAPON_EMPTYHANDS = 1, P3_WEAPON_WOLVERINE = 2, P3_WEAPON_NAILBAT = 3, P3_WEAPON_GRENADE = 4, P3_WEAPON_DESERT_EAGLE = 5, P3_WEAPON_TASER = 6, P3_WEAPON_SHOTGUN = 7, // auto shotgun P3_WEAPON_M60 = 8, P3_WEAPON_M16 = 9, P3_WEAPON_CAT = 10, P3_WEAPON_MACHETE = 11, P3_WEAPON_SHOVEL = 12, P3_WEAPON_MOLOTOV = 13, P3_WEAPON_GASOLINE = 14, P3_WEAPON_CATNIP = 15, P3_WEAPON_BANNER = 16, P3_WEAPON_BEENEST = 17, P3_WEAPON_COP_BATON = 18, P3_WEAPON_KROTCHY_GRENADE = 19, P3_WEAPON_HAMMER = 20, P3_WEAPON_LASERPEN = 21, P3_WEAPON_MATCH = 22, P3_WEAPON_MAXEL_SNIPER = 23, // doesn't exist P3_WEAPON_METABULKY = 24, // unused P3_WEAPON_METAONEHANDLED = 25, P3_WEAPON_METATWOHANDLED = 26, // unused P3_WEAPON_MONKEY = 27, P3_WEAPON_PHOTOCAM = 28, P3_WEAPON_SEED = 29, // unused P3_WEAPON_SHOPVAC = 30, P3_WEAPON_SPRAY = 31, P3_WEAPON_TVCAM = 32, P3_WEAPON_WEEMOTE = 33, P3_WEAPON_M136 = 34, P3_WEAPON_FIREAXE = 35, P3_WEAPON_GAMAMET = 36, P3_WEAPON_COUNT };","title":"Weapon ID"},{"location":"flags/#weapon-type","text":"shared enum WeaponType_t { WPN_TYPE_FLESH = -1, WPN_TYPE_NONE = 0, WPN_TYPE_ANIMAL, WPN_TYPE_GADGET, WPN_TYPE_NONLETHAL_MELEE, WPN_TYPE_NONLETHAL_RANGED, WPN_TYPE_MELEE, WPN_TYPE_RANGED, WPN_TYPE_BIGGUN, WPN_TYPE_SIZE };","title":"Weapon Type"},{"location":"flags/#say","text":"shared enum SentencePriority_t { SENTENCE_PRIORITY_INVALID = -1, SENTENCE_PRIORITY_NORMAL = 0, SENTENCE_PRIORITY_MEDIUM = 1, SENTENCE_PRIORITY_HIGH = 2 };","title":"Say"},{"location":"flags/#sequence","text":"shared enum Sequence_t { SEQUENCE_NONE = 0, SEQUENCE_AIM = 1, SEQUENCE_NO_ACTION_CHECK = 2 };","title":"Sequence"},{"location":"flags/#inventory","text":"shared enum Inventory_t { INV_SELECT = 0, INV_EQUIP = 1, INV_ADD = 2, INV_REMOVE = 3 };","title":"Inventory"},{"location":"flags/#movement-type","text":"shared enum P3AI_MovementType_t { AIMT_CURRENT, AIMT_WALK, AIMT_RUN, AIMT_MIX, AIMT_FLY, AIMT_RANDOM, AIMT_OFF, AIMT_TELEPORT };","title":"Movement Type"},{"location":"flags/#face-type","text":"shared enum P3AI_FaceType_t { AIFT_FACE_NONE, AIFT_FACE_TO_TARGET, AIFT_FACE_FROM_TARGET, AIFT_FACE_AS_TARGET };","title":"Face Type"},{"location":"flags/#move-to-target","text":"shared enum P3AI_MoveToTarget_Flags { AIMTF_NONE = 0x0000, AIMTF_ACCURATE_POSITIONING = 0x0001 };","title":"Move To Target"},{"location":"flags/#local-time","text":"shared enum LocalTime_t { LT_YEAR = 0, // Local year LT_MONTH, // Local month LT_DAY, // Local day LT_HOURS, // Local hours LT_MINUTES, // Local minutes LT_SECONDS, // Local seconds LT_DAYS_JANUARY, // Days since January (0,365) LT_DAYS,SUNDAY, // Days since Sunday (0,6) LT_FLAG // daylight savings time flag };","title":"Local Time"},{"location":"flags/#fade-flags","text":"shared enum FadeFlags_t { FFADE_IN = 0x0001, FFADE_OUT = 0x0002, FFADE_MODULATE = 0x0004, FFADE_STAYOUT = 0x0008, FFADE_PURGE = 0x0010 };","title":"Fade Flags"},{"location":"flags/#sub-flags","text":"shared enum SubFlags_t { SUB_Remove = 0, SUB_DoNothing, SUB_StartFadeOut, SUB_FadeOut, SUB_Vanish, SUB_CallUseToggle, SUB_PerformFadeOut };","title":"Sub Flags"},{"location":"flags/#collision-groups","text":"shared enum Collision_Group_t { COLLISION_GROUP_NONE = 0, COLLISION_GROUP_DEBRIS, // Collides with nothing but world and static stuff COLLISION_GROUP_DEBRIS_TRIGGER, // Same as debris, but hits triggers COLLISION_GROUP_INTERACTIVE_DEBRIS, // Collides with everything except other interactive debris or debris COLLISION_GROUP_INTERACTIVE, // Collides with everything except interactive debris or debris COLLISION_GROUP_PLAYER, COLLISION_GROUP_BREAKABLE_GLASS, COLLISION_GROUP_VEHICLE, COLLISION_GROUP_PLAYER_MOVEMENT, // For HL2, same as Collision_Group_Player, for // TF2, this filters out other players and CBaseObjects COLLISION_GROUP_NPC, // Generic NPC group COLLISION_GROUP_IN_VEHICLE, // for any entity inside a vehicle COLLISION_GROUP_WEAPON, // for any weapons that need collision detection COLLISION_GROUP_VEHICLE_CLIP, // vehicle clip brush to restrict vehicle movement COLLISION_GROUP_PROJECTILE, // Projectiles! COLLISION_GROUP_DOOR_BLOCKER, // Blocks entities not permitted to get near moving doors COLLISION_GROUP_PASSABLE_DOOR, // Doors that the player shouldn't collide with COLLISION_GROUP_DISSOLVING, // Things that are dissolving are in this group COLLISION_GROUP_PUSHAWAY, // Nonsolid on client and server, pushaway in player code COLLISION_GROUP_NPC_ACTOR, // Used so NPCs in scripts ignore the player. COLLISION_GROUP_NPC_SCRIPTED, // USed for NPCs in scripts that should not collide with each other COLLISION_GROUP_AREAGROUP_VOLUME, COLLISION_GROUP_RAGDOLL, // Collides with everything except NPC, player and vehicle COLLISION_GROUP_BREAKABLE_BY_VEHICLE, COLLISION_GROUP_NOTHING, LAST_SHARED_COLLISION_GROUP };","title":"Collision Groups"},{"location":"flags/#solid-flags","text":"shared enum SolidFlags_t { FSOLID_CUSTOMRAYTEST = 0x0001, // Ignore solid type + always call into the entity for ray tests FSOLID_CUSTOMBOXTEST = 0x0002, // Ignore solid type + always call into the entity for swept box tests FSOLID_NOT_SOLID = 0x0004, // Are we currently not solid? FSOLID_TRIGGER = 0x0008, // This is something may be collideable but fires touch functions // even when it's not collideable (when the FSOLID_NOT_SOLID flag is set) FSOLID_NOT_STANDABLE = 0x0010, // You can't stand on this FSOLID_VOLUME_CONTENTS = 0x0020, // Contains volumetric contents (like water) FSOLID_FORCE_WORLD_ALIGNED = 0x0040, // Forces the collision rep to be world-aligned even if it's SOLID_BSP or SOLID_VPHYSICS FSOLID_USE_TRIGGER_BOUNDS = 0x0080, // Uses a special trigger bounds separate from the normal OBB FSOLID_ROOT_PARENT_ALIGNED = 0x0100, // Collisions are defined in root parent's local coordinate space FSOLID_TRIGGER_TOUCH_DEBRIS = 0x0200, // This trigger will touch debris objects FSOLID_PROHIBITED_AREA = 0x0400, // Prohibited areas FSOLID_MAX_BITS = 11 };","title":"Solid Flags"},{"location":"flags/#solid-types","text":"shared enum SolidType_t { SOLID_NONE = 0, // no solid model SOLID_BSP = 1, // a BSP tree SOLID_BBOX = 2, // an AABB SOLID_OBB = 3, // an OBB (not implemented yet) SOLID_OBB_YAW = 4, // an OBB, constrained so that it can only yaw SOLID_CUSTOM = 5, // Always call into the entity for tests SOLID_VPHYSICS = 6, // solid vphysics object, get vcollide from the model and collide with that SOLID_SPHERE = 7, // an sphere SOLID_LAST, };","title":"Solid types"},{"location":"flags/#entity-effects","text":"shared enum EntityEffect_t { EF_BONEMERGE = 0x001, // Performs bone merge on client side EF_BRIGHTLIGHT = 0x002, // DLIGHT centered at entity origin EF_DIMLIGHT = 0x004, // player flashlight EF_NOINTERP = 0x008, // don't interpolate the next frame EF_NOSHADOW = 0x010, // Don't cast no shadow EF_NODRAW = 0x020, // don't draw entity EF_NORECEIVESHADOW = 0x040, // Don't receive no shadow EF_BONEMERGE_FASTCULL = 0x080, // For use with EF_BONEMERGE. If this is set, then it places this ent's origin at its // parent and uses the parent's bbox + the max extents of the aiment. // Otherwise, it sets up the parent's bones every frame to figure out where to place // the aiment, which is inefficient because it'll setup the parent's bones even if // the parent is not in the PVS. EF_ITEM_BLINK = 0x100, // blink an item so that the user notices it. EF_PARENT_ANIMATES = 0x200, // always assume that the parent entity is animating EF_MIRROR_WEAPON = 0x400, EF_MAX_BITS = 11 };","title":"Entity Effects"},{"location":"flags/#cvar-flags","text":"shared enum FCVAR_t { FCVAR_NONE = 0, FCVAR_UNREGISTERED = (1<<0), FCVAR_DEVELOPMENTONLY = (1<<1), FCVAR_GAMEDLL = (1<<2), FCVAR_CLIENTDLL = (1<<3), FCVAR_HIDDEN = (1<<4), FCVAR_PROTECTED = (1<<5), FCVAR_SPONLY = (1<<6), FCVAR_ARCHIVE = (1<<7), FCVAR_NOTIFY = (1<<8), FCVAR_USERINFO = (1<<9), FCVAR_CHEAT = (1<<14), FCVAR_PRINTABLEONLY = (1<<10), FCVAR_UNLOGGED = (1<<11), FCVAR_NEVER_AS_STRING = (1<<12), FCVAR_REPLICATED = (1<<13), FCVAR_DEMO = (1<<16), FCVAR_DONTRECORD = (1<<17), FCVAR_RELOAD_MATERIALS = (1<<20), FCVAR_RELOAD_TEXTURES = (1<<21), FCVAR_NOT_CONNECTED = (1<<22), FCVAR_MATERIAL_SYSTEM_THREAD = (1<<23), FCVAR_ARCHIVE_XBOX = (1<<24), FCVAR_ACCESSIBLE_FROM_THREADS = (1<<25), FCVAR_SERVER_CAN_EXECUTE = (1<<28), FCVAR_SERVER_CANNOT_QUERY = (1<<29), FCVAR_CLIENTCMD_CAN_EXECUTE = (1<<30), FCVAR_MATERIAL_THREAD_MASK = ( FCVAR_RELOAD_MATERIALS | FCVAR_RELOAD_TEXTURES | FCVAR_MATERIAL_SYSTEM_THREAD ) };","title":"Cvar flags"},{"location":"flags/#take-damage-flags","text":"shared enum Damage_t { DMG_GENERIC = 0, // generic damage -- do not use if you want players to flinch and bleed! DMG_CRUSH = (1 << 0), // crushed by falling or moving object. // NOTE: It's assumed crush damage is occurring as a result of physics collision, so no extra physics force is generated by crush damage. // DON'T use DMG_CRUSH when damaging entities unless it's the result of a physics collision. You probably want DMG_CLUB instead. DMG_BULLET = (1 << 1), // shot DMG_SLASH = (1 << 2), // cut, clawed, stabbed DMG_BURN = (1 << 3), // heat burned DMG_VEHICLE = (1 << 4), // hit by a vehicle DMG_FALL = (1 << 5), // fell too far DMG_BLAST = (1 << 6), // explosive blast damage DMG_CLUB = (1 << 7), // crowbar, punch, headbutt DMG_SHOCK = (1 << 8), // electric shock DMG_SONIC = (1 << 9), // sound pulse shockwave DMG_ENERGYBEAM = (1 << 10), // laser or other high energy beam DMG_PREVENT_PHYSICS_FORCE = (1 << 11), // Prevent a physics force DMG_NEVERGIB = (1 << 12), // with this bit OR'd in, no damage type will be able to gib victims upon death DMG_ALWAYSGIB = (1 << 13), // with this bit OR'd in, any damage type can be made to gib victims upon death. DMG_DROWN = (1 << 14), // Drowning DMG_PARALYZE = (1 << 15), // slows affected creature down DMG_NERVEGAS = (1 << 16), // nerve toxins, very bad DMG_POISON = (1 << 17), // blood poisoning - heals over time like drowning damage DMG_RADIATION = (1 << 18), // radiation exposure DMG_DROWNRECOVER = (1 << 19), // drowning recovery DMG_ACID = (1 << 20), // toxic chemicals or acid burns DMG_SLOWBURN = (1 << 21), // in an oven DMG_REMOVENORAGDOLL = (1<<22), // with this bit OR'd in, no ragdoll will be created, and the target will be quietly removed. // use this to kill an entity that you've already got a server-side ragdoll for DMG_PHYSGUN = (1<<23), // Hit by manipulator. Usually doesn't do any damage. DMG_PLASMA = (1<<24), // Shot by Cremator DMG_AIRBOAT = (1<<25), // Hit by the airboat's gun DMG_DISSOLVE = (1<<26), // Dissolving! DMG_BLAST_SURFACE = (1<<27), // A blast on the surface of water that cannot harm things underwater DMG_DIRECT = (1<<28), DMG_BUCKSHOT = (1<<29), // not quite a bullet. Little, rounder, different. DMG_KNUCKLE = (DMG_DIRECT | DMG_CLUB | DMG_NEVERGIB), DMG_KICK = (DMG_KNUCKLE | DMG_REMOVENORAGDOLL), DMG_BATON = (DMG_DIRECT | DMG_FALL | DMG_CLUB), DMG_SHOVEL = (DMG_DIRECT | DMG_SLASH), DMG_SHOVEL2 = (DMG_DIRECT | DMG_SLASH | DMG_CLUB), DMG_HAMMER = (DMG_DIRECT | DMG_VEHICLE | DMG_CLUB), DMG_NAILBAT = (DMG_DIRECT | DMG_VEHICLE | DMG_CLUB | DMG_BULLET) }","title":"Take damage flags"},{"location":"flags/#entity-flags","text":"shared enum EntFlags_t { FL_ONGROUND = (1<<0), // At rest / on the ground FL_DUCKING = (1<<1), // Player flag -- Player is fully crouched FL_WATERJUMP = (1<<2), // player jumping out of water FL_ONTRAIN = (1<<3), // Player is _controlling_ a train, so movement commands should be ignored on client during prediction. FL_INRAIN = (1<<4), // Indicates the entity is standing in rain FL_FROZEN = (1<<5), // Player is frozen for 3rd person camera FL_ATCONTROLS = (1<<6), // Player can't move, but keeps key inputs for controlling another entity FL_CLIENT = (1<<7), // Is a player FL_FAKECLIENT = (1<<8), // Fake client, simulated server side; don't send network messages to them // NON-PLAYER SPECIFIC = (i.e., not used by GameMovement or the client .dll ), -- Can still be applied to players, though FL_INWATER = (1<<9), // In water FL_FLY = (1<<10), // Changes the SV_Movestep= (), behavior to not need to be on ground FL_SWIM = (1<<11), // Changes the SV_Movestep= (), behavior to not need to be on ground = (but stay in water), FL_CONVEYOR = (1<<12), FL_NPC = (1<<13), FL_GODMODE = (1<<14), FL_NOTARGET = (1<<15), FL_AIMTARGET = (1<<16), // set if the crosshair needs to aim onto the entity FL_PARTIALGROUND = (1<<17), // not all corners are valid FL_STATICPROP = (1<<18), // Eetsa static prop! FL_GRAPHED = (1<<19), // worldgraph has this ent listed as something that blocks a connection FL_GRENADE = (1<<20), FL_STEPMOVEMENT = (1<<21), // Changes the SV_Movestep= (), behavior to not do any processing FL_DONTTOUCH = (1<<22), // Doesn't generate touch functions, generates Untouch= (), for anything it was touching when this flag was set FL_BASEVELOCITY = (1<<23), // Base velocity has been applied this frame = (used to convert base velocity into momentum), FL_WORLDBRUSH = (1<<24), // Not moveable/removeable brush entity = (really part of the world, but represented as an entity for transparency or something), FL_OBJECT = (1<<25), // Terrible name. This is an object that NPCs should see. Missiles, for example. FL_KILLME = (1<<26), // This entity is marked for death -- will be freed by game DLL FL_ONFIRE = (1<<27), // You know... FL_DISSOLVING = (1<<28), // We're dissolving! FL_TRANSRAGDOLL = (1<<29), // In the process of turning into a client side ragdoll. FL_UNBLOCKABLE_BY_PLAYER = (1<<30), // pusher that can't be blocked by the player FL_JUMPING = (1<<31) // player jumping }","title":"Entity Flags"},{"location":"flags/#bsp-flags","text":"shared enum BSPFlags_t { // lower bits are stronger, and will eat weaker brushes completely CONTENTS_EMPTY = 0, // No contents CONTENTS_SOLID = 0x1, // an eye is never valid in a solid CONTENTS_WINDOW = 0x2, // translucent, but not watery (glass) CONTENTS_AUX = 0x4, CONTENTS_GRATE = 0x8, // alpha-tested \"grate\" textures. Bullets/sight pass through, but solids don't CONTENTS_SLIME = 0x10, CONTENTS_WATER = 0x20, CONTENTS_BLOCKLOS = 0x40, // block AI line of sight CONTENTS_OPAQUE = 0x80, // things that cannot be seen through (may be non-solid though) LAST_VISIBLE_CONTENTS = 0x80, ALL_VISIBLE_CONTENTS = (LAST_VISIBLE_CONTENTS | (LAST_VISIBLE_CONTENTS-1)), CONTENTS_TESTFOGVOLUME = 0x100, CONTENTS_UNUSED = 0x200, // unused // NOTE: If it's visible, grab from the top + update LAST_VISIBLE_CONTENTS // if not visible, then grab from the bottom. CONTENTS_UNUSED6 = 0x400, CONTENTS_TEAM1 = 0x800, // per team contents used to differentiate collisions CONTENTS_TEAM2 = 0x1000, // between players and objects on different teams CONTENTS_IGNORE_NODRAW_OPAQUE = 0x2000, // ignore CONTENTS_OPAQUE on surfaces that have SURF_NODRAW CONTENTS_MOVEABLE = 0x4000, // hits entities which are MOVETYPE_PUSH (doors, plats, etc.) CONTENTS_AREAPORTAL = 0x8000, CONTENTS_PLAYERCLIP = 0x10000, CONTENTS_MONSTERCLIP = 0x20000, CONTENTS_CURRENT_0 = 0x40000, CONTENTS_CURRENT_90 = 0x80000, CONTENTS_CURRENT_180 = 0x100000, CONTENTS_CURRENT_270 = 0x200000, CONTENTS_CURRENT_UP = 0x400000, CONTENTS_CURRENT_DOWN = 0x800000, CONTENTS_ORIGIN = 0x1000000, CONTENTS_MONSTER = 0x2000000, CONTENTS_DEBRIS = 0x4000000, CONTENTS_DETAIL = 0x8000000, CONTENTS_TRANSLUCENT = 0x10000000, CONTENTS_LADDER = 0x20000000, CONTENTS_HITBOX = 0x40000000, SURF_LIGHT = 0x0001, SURF_SKY2D = 0x0002, SURF_SKY = 0x0004, SURF_WARP = 0x0008, SURF_TRANS = 0x0010, SURF_NOPORTAL = 0x0020, SURF_TRIGGER = 0x0040, SURF_NODRAW = 0x0080, SURF_HINT = 0x0100, SURF_SKIP = 0x0200, SURF_NOLIGHT = 0x0400, SURF_BUMPLIGHT = 0x0800, SURF_NOSHADOWS = 0x1000, SURF_NODECALS = 0x2000, SURF_NOCHOP = 0x4000, SURF_HITBOX = 0x8000, // ----------------------------------------------------- // spatial content masks - used for spatial queries (traceline,etc.) // ----------------------------------------------------- MASK_ALL = (0xFFFFFFFF), MASK_SOLID = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE), // everything that blocks player movement MASK_PLAYERSOLID = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE), // blocks npc movement MASK_NPCSOLID = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE), // water physics in these contents MASK_WATER = (CONTENTS_WATER|CONTENTS_MOVEABLE|CONTENTS_SLIME), // everything that blocks lighting MASK_OPAQUE = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_OPAQUE), // everything that blocks lighting, but with monsters added. MASK_OPAQUE_AND_NPCS = (MASK_OPAQUE|CONTENTS_MONSTER), // everything that blocks line of sight for AI MASK_BLOCKLOS = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_BLOCKLOS), // everything that blocks line of sight for AI plus NPCs MASK_BLOCKLOS_AND_NPCS = (MASK_BLOCKLOS|CONTENTS_MONSTER), // everything that blocks line of sight for players MASK_VISIBLE = (MASK_OPAQUE|CONTENTS_IGNORE_NODRAW_OPAQUE), // everything that blocks line of sight for players, but with monsters added. MASK_VISIBLE_AND_NPCS = (MASK_OPAQUE_AND_NPCS|CONTENTS_IGNORE_NODRAW_OPAQUE), // bullets see these as solid MASK_SHOT = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX), // non-raycasted weapons see this as solid = (includes grates), MASK_SHOT_HULL = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE), // hits solids = (not grates), and passes through everything else MASK_SHOT_PORTAL = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER), // everything normally solid, except monsters = (world+brush only), MASK_SOLID_BRUSHONLY = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_GRATE), // everything normally solid for player movement, except monsters = (world+brush only), MASK_PLAYERSOLID_BRUSHONLY = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_PLAYERCLIP|CONTENTS_GRATE), // everything normally solid for npc movement, except monsters = (world+brush only), MASK_NPCSOLID_BRUSHONLY = (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE), // just the world, used for route rebuilding MASK_NPCWORLDSTATIC = (CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE), // These are things that can split areaportals MASK_SPLITAREAPORTAL = (CONTENTS_WATER|CONTENTS_SLIME), // UNDONE: This is untested, any moving water MASK_CURRENT = (CONTENTS_CURRENT_0|CONTENTS_CURRENT_90|CONTENTS_CURRENT_180|CONTENTS_CURRENT_270|CONTENTS_CURRENT_UP|CONTENTS_CURRENT_DOWN), // everything that blocks corpse movement // UNDONE: Not used yet / may be deleted MASK_DEADSOLID = (CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_GRATE), }","title":"BSP Flags"},{"location":"flags/#spawn-flags","text":"shared enum SpawnFlags_t { SF_NPC_WAIT_TILL_SEEN = ( 1 << 0 ), // spawnflag that makes npcs wait until player can see them before attacking. SF_NPC_GAG = ( 1 << 1 ), // no idle noises from this npc SF_NPC_FALL_TO_GROUND = ( 1 << 2 ), // used my NPC_Maker SF_NPC_DROP_HEALTHKIT = ( 1 << 3 ), // Drop a healthkit upon death SF_NPC_START_EFFICIENT = ( 1 << 4 ), // Set into efficiency mode from spawn // = ( 1 << 5 ), // = ( 1 << 6 ), SF_NPC_WAIT_FOR_SCRIPT = ( 1 << 7 ), // spawnflag that makes npcs wait to check for attacking until the script is done or they've been attacked SF_NPC_LONG_RANGE = ( 1 << 8 ), // makes npcs look far and relaxes weapon range limit SF_NPC_FADE_CORPSE = ( 1 << 9 ), // Fade out corpse after death SF_NPC_ALWAYSTHINK = ( 1 << 10 ), // Simulate even when player isn't in PVS. SF_NPC_TEMPLATE = ( 1 << 11 ), // This NPC will be used as a template by an npc_maker -- do not spawn. SF_NPC_ALTCOLLISION = ( 1 << 12 ), SF_NPC_NO_WEAPON_DROP = ( 1 << 13 ), // This NPC will not actually drop a weapon that can be picked up SF_NPC_NO_PLAYER_PUSHAWAY = ( 1 << 14 ), // = ( 1 << 15 ), // !! Flags above = ( 1 << 15 ), are reserved for NPC sub-classes SF_NPC_INTERACTABLE = (1<<30), }","title":"Spawn flags"},{"location":"introduction/","text":"Welcome to AngelScript \uf0c1 AngelScript is a scripting language which allows applications to extend their functionality through external scripts. To put it simple, it is a scripting language like Postal3Script, but it is very different from P3S, it has it's own compiler, and it's way faster (also a lot more stable) in terms of code execution. AngelScript is used as a layer for Postal3Script, which allows you to create complex code while still having P3S features. You can read more about AngelScript here: http://angelcode.com/angelscript/ If you need a comprehensive list of all objects and functions, go back to the Index . Why AngelScript? \uf0c1 Postal3Script has always been a very obscure scripting language, lack of documentation, weird syntax, and a very odd layout, which is unlike any other scripting languages out there. As Catharsis Reborn extended the AI of all NPCs, so did the code too, but this where the cracks began to appear. Spaghetti, ping-pong code writing from 'A' File, to 'B' File, ridiculously increasing lines where a single Block can go from 1 to 100, and it was very hard to go back and try to fix something wrong with the behavior you wrote, because it's not that very clear at first glance (especially when it's all over the place), to really use Postal3Script you have to learn the ins and outs, and even after a month you won't fully grasp it. (just remember that in 2016 the team was struggling with P3S!) So there had to be a way of doing complex code without Postal3Script, at first (2020-2022) many of the complex behaviors were hardcoded inside the source code because Postal3Script wasn't fully understood back then. Slowly every hardcoded code were put into Postal3Script instead where it was obvious they must be there. (Inventory items for instance, due to scripting) Creating dynamic events (such as the Wanted Reinforcements) without relying on modifying the maps and compiling back them everytime, was very, very questionable if it could be done with Postal3Script. LUA was a 'Block' monstrosity like Postal3Script, and it wouldn't have been that easy to implement it in CR, so we went with AngelScript. Postal3Script vs. AngelScript \uf0c1 Here are several facts about P3S: Hard to learn Only compiled when map restarts (can't force-recompile) Structure has a strict rule Compilation errors not always make sense Complex code might cause the AI to not work properly Very sensitive to spaces, tabs (heavily depends on how the function's compiler was programmed) Creativity isn't rewarded Complexity equals Spaghetti Extremely limited by functions in how you can interact with other entities Point of crashes are commonly very unclear AngelScript has none of that, but this time spaghetti equals to programming skill. AngelScript can access Postal3Script internal functions, like target, caller, memory, weapon, etc.. combine that with C++ syntax and you would get something like Postal3Script++. On top of having access to almost all cruical Postal3Script functions, AngelScript also has access to normally inaccessible functions which you would only be able to use with the game's source code. Here's an example below how one code looks in P3S and in AS. (behavior stays the same) Note The P3S code below only works for Catharsis Reborn, but you can still observe the amount of bloat it removes when converted to AngelScript. Postal3Script: IfAttr \"cr_NoArms != 1 Block begin\" IfAttr \"cr_NoRArm != 1 Block begin\" SetAttr \"wpnattack 0\" IfAttr \"Object:weapon != Object:NULL Block begin\" IfAttr \"weapon.weapon_id != WPN_NONE Block begin\" IfAttr \"weapon.weapon_type == WPN_MELEE SetAttr wpnattack 1\" IfAttr \"weapon.weapon_type == WPN_LIMB SetAttr wpnattack 1\" Block end Block end IfAttr \"wpnattack == 1 Block begin\" RemoveAttr \"wpnattack\" Pattern pt_attack Block end RemoveAttr \"wpnattack\" Block end Block end AngelScript: if (self.GetAttr(\"cr_NoArms\") != 1 && self.GetAttr(\"cr_NoRArm\") != 1) { if (self.GetWeapon() != null) { int wpnType = self.GetWeapon().GetAttr(\"weapon_type\"); if (wpnType == WPN_MELEE || wpnType == WPN_LIMB) { self.Pattern(\"pt_attack\"); } } } You can see how we greatly reduced the lines, and it's even clearer to understand and look at! With AngelScript we can also get all the NPCs on the level, and check their manner, faction, state, health, etc.. all you can imagine, this is where Postal3Script stays in the dark in terms of usefulness, you can't fully interact with the level with P3S.","title":"Introduction"},{"location":"introduction/#welcome-to-angelscript","text":"AngelScript is a scripting language which allows applications to extend their functionality through external scripts. To put it simple, it is a scripting language like Postal3Script, but it is very different from P3S, it has it's own compiler, and it's way faster (also a lot more stable) in terms of code execution. AngelScript is used as a layer for Postal3Script, which allows you to create complex code while still having P3S features. You can read more about AngelScript here: http://angelcode.com/angelscript/ If you need a comprehensive list of all objects and functions, go back to the Index .","title":"Welcome to AngelScript"},{"location":"introduction/#why-angelscript","text":"Postal3Script has always been a very obscure scripting language, lack of documentation, weird syntax, and a very odd layout, which is unlike any other scripting languages out there. As Catharsis Reborn extended the AI of all NPCs, so did the code too, but this where the cracks began to appear. Spaghetti, ping-pong code writing from 'A' File, to 'B' File, ridiculously increasing lines where a single Block can go from 1 to 100, and it was very hard to go back and try to fix something wrong with the behavior you wrote, because it's not that very clear at first glance (especially when it's all over the place), to really use Postal3Script you have to learn the ins and outs, and even after a month you won't fully grasp it. (just remember that in 2016 the team was struggling with P3S!) So there had to be a way of doing complex code without Postal3Script, at first (2020-2022) many of the complex behaviors were hardcoded inside the source code because Postal3Script wasn't fully understood back then. Slowly every hardcoded code were put into Postal3Script instead where it was obvious they must be there. (Inventory items for instance, due to scripting) Creating dynamic events (such as the Wanted Reinforcements) without relying on modifying the maps and compiling back them everytime, was very, very questionable if it could be done with Postal3Script. LUA was a 'Block' monstrosity like Postal3Script, and it wouldn't have been that easy to implement it in CR, so we went with AngelScript.","title":"Why AngelScript?"},{"location":"introduction/#postal3script-vs-angelscript","text":"Here are several facts about P3S: Hard to learn Only compiled when map restarts (can't force-recompile) Structure has a strict rule Compilation errors not always make sense Complex code might cause the AI to not work properly Very sensitive to spaces, tabs (heavily depends on how the function's compiler was programmed) Creativity isn't rewarded Complexity equals Spaghetti Extremely limited by functions in how you can interact with other entities Point of crashes are commonly very unclear AngelScript has none of that, but this time spaghetti equals to programming skill. AngelScript can access Postal3Script internal functions, like target, caller, memory, weapon, etc.. combine that with C++ syntax and you would get something like Postal3Script++. On top of having access to almost all cruical Postal3Script functions, AngelScript also has access to normally inaccessible functions which you would only be able to use with the game's source code. Here's an example below how one code looks in P3S and in AS. (behavior stays the same) Note The P3S code below only works for Catharsis Reborn, but you can still observe the amount of bloat it removes when converted to AngelScript. Postal3Script: IfAttr \"cr_NoArms != 1 Block begin\" IfAttr \"cr_NoRArm != 1 Block begin\" SetAttr \"wpnattack 0\" IfAttr \"Object:weapon != Object:NULL Block begin\" IfAttr \"weapon.weapon_id != WPN_NONE Block begin\" IfAttr \"weapon.weapon_type == WPN_MELEE SetAttr wpnattack 1\" IfAttr \"weapon.weapon_type == WPN_LIMB SetAttr wpnattack 1\" Block end Block end IfAttr \"wpnattack == 1 Block begin\" RemoveAttr \"wpnattack\" Pattern pt_attack Block end RemoveAttr \"wpnattack\" Block end Block end AngelScript: if (self.GetAttr(\"cr_NoArms\") != 1 && self.GetAttr(\"cr_NoRArm\") != 1) { if (self.GetWeapon() != null) { int wpnType = self.GetWeapon().GetAttr(\"weapon_type\"); if (wpnType == WPN_MELEE || wpnType == WPN_LIMB) { self.Pattern(\"pt_attack\"); } } } You can see how we greatly reduced the lines, and it's even clearer to understand and look at! With AngelScript we can also get all the NPCs on the level, and check their manner, faction, state, health, etc.. all you can imagine, this is where Postal3Script stays in the dark in terms of usefulness, you can't fully interact with the level with P3S.","title":"Postal3Script vs. AngelScript"},{"location":"serialization/","text":"Serialization \uf0c1 AngelScript is capable of some serialization, however not everything will be saved to save file, and there are some limitations to be wary of. Unsafe \uf0c1 Unsafe The following points below will cause the serialization process to be aborted, or in worst case scenario cause the game to crash. It will only happen if current script module doesn't match with the saved script module's content. Changing variable order in script classes Adding new/removing variables in script classes Adding new/removing script classes Changing the order of how script classes (or variables) are loaded Safe \uf0c1 Safe The following points below are OKAY to do, and it will not cause any problems when loading a save file. Adding new functions Modifying functions or how they behave Serialization List \uf0c1 When the cached object is being prepared to be serialized, the game will go through each datatype/object and check if they could be saved. If the Datatype/Object cannot be serialized, the game will just ignore it. It's highly recommended to do manual restoration for certain objects like CSoundPatch@ which cannot be serialized. Typically objects that derive from CBaseEntity@ can be serialized, other objects may or may not be serializable. Warning Const datatypes or objects will not be serialized, they will be ignored. Paused contexts/executions (via Wait function) will not be serialized. Datatype/Object Is Serialized Note(s) bool YES n/a int YES n/a float YES n/a double PARTIALLY Automatically converted to float type on compilation uint YES n/a array PARTIALLY (?) Multi-dimension arrays have not been tested, single arrays work fine any NO n/a int8 NO Use int instead int16 NO Use int instead int32 NO Use int instead int64 NO Use int instead uint8 NO Use uint instead uint16 NO Use uint instead uint32 NO Use uint instead uint64 NO Use uint instead dictionary NO Use arrays instead ref NO n/a weakref NO n/a string YES n/a string_t YES n/a Vector YES n/a QAngle YES n/a AngularImpulse YES n/a CBaseEntity@ YES n/a EHANDLE YES n/a CP3SObj@ YES Serializes P3S Obj via Base Entity pointer ConVar@ PARTIALLY Serializes only the value, other values (like help text and callback) are lost CP3Weapon@ YES Serializes via Base Entity pointer CP3Player@ YES Serializes via Base Entity pointer CParticleSystem@ YES Serializes via Base Entity pointer CPhysObj@ YES Iterates via entity list to match with pointer CCutsceneCamera@ YES Serializes via Base Entity pointer CSoundPatch@ NO Sounds cannot be serialized, requires manual restoration IGameEvent@ NO Game events cannot be stored CTakeDamageInfo@ NO Currently no way to properly store CWPNData@ NO Data might change between saves Ammo_t@ NO Data might change between saves KeyValues@ NO n/a CAINetworkManager@ NO There is a global var for this type IGameEventManager@ NO There is a global var for this type CGlobalVars@ NO There is a global var for this type CAI_Hint@ YES n/a","title":"Serialization"},{"location":"serialization/#serialization","text":"AngelScript is capable of some serialization, however not everything will be saved to save file, and there are some limitations to be wary of.","title":"Serialization"},{"location":"serialization/#unsafe","text":"Unsafe The following points below will cause the serialization process to be aborted, or in worst case scenario cause the game to crash. It will only happen if current script module doesn't match with the saved script module's content. Changing variable order in script classes Adding new/removing variables in script classes Adding new/removing script classes Changing the order of how script classes (or variables) are loaded","title":"Unsafe"},{"location":"serialization/#safe","text":"Safe The following points below are OKAY to do, and it will not cause any problems when loading a save file. Adding new functions Modifying functions or how they behave","title":"Safe"},{"location":"serialization/#serialization-list","text":"When the cached object is being prepared to be serialized, the game will go through each datatype/object and check if they could be saved. If the Datatype/Object cannot be serialized, the game will just ignore it. It's highly recommended to do manual restoration for certain objects like CSoundPatch@ which cannot be serialized. Typically objects that derive from CBaseEntity@ can be serialized, other objects may or may not be serializable. Warning Const datatypes or objects will not be serialized, they will be ignored. Paused contexts/executions (via Wait function) will not be serialized. Datatype/Object Is Serialized Note(s) bool YES n/a int YES n/a float YES n/a double PARTIALLY Automatically converted to float type on compilation uint YES n/a array PARTIALLY (?) Multi-dimension arrays have not been tested, single arrays work fine any NO n/a int8 NO Use int instead int16 NO Use int instead int32 NO Use int instead int64 NO Use int instead uint8 NO Use uint instead uint16 NO Use uint instead uint32 NO Use uint instead uint64 NO Use uint instead dictionary NO Use arrays instead ref NO n/a weakref NO n/a string YES n/a string_t YES n/a Vector YES n/a QAngle YES n/a AngularImpulse YES n/a CBaseEntity@ YES n/a EHANDLE YES n/a CP3SObj@ YES Serializes P3S Obj via Base Entity pointer ConVar@ PARTIALLY Serializes only the value, other values (like help text and callback) are lost CP3Weapon@ YES Serializes via Base Entity pointer CP3Player@ YES Serializes via Base Entity pointer CParticleSystem@ YES Serializes via Base Entity pointer CPhysObj@ YES Iterates via entity list to match with pointer CCutsceneCamera@ YES Serializes via Base Entity pointer CSoundPatch@ NO Sounds cannot be serialized, requires manual restoration IGameEvent@ NO Game events cannot be stored CTakeDamageInfo@ NO Currently no way to properly store CWPNData@ NO Data might change between saves Ammo_t@ NO Data might change between saves KeyValues@ NO n/a CAINetworkManager@ NO There is a global var for this type IGameEventManager@ NO There is a global var for this type CGlobalVars@ NO There is a global var for this type CAI_Hint@ YES n/a","title":"Serialization List"},{"location":"syntaxhighlight/","text":"Syntax Highlighter \uf0c1 Notepad++ \uf0c1 Note Dark mode only This syntax highlighter is included with Angel mod, you can find it in the syntax folder. Auto-completion support (although a little bit messy) Installation \uf0c1 Go to in Notepad++ Language->User Defined Language->Open User Defined Language folder... place angelscript_wj.xml there. Go to C:\\Notepad++\\autoCompletion\\ place angelscript_wj.xml there from the autoCompletion zip's folder. Go to C:\\Notepad++\\functionList\\ place angelscript_wj.xml there from the functionList zip's folder. Restart Notepad++. Notepad++ should now recognize *.as files. Visual Studio Code \uf0c1 TODO","title":"Syntax Highlighter"},{"location":"syntaxhighlight/#syntax-highlighter","text":"","title":"Syntax Highlighter"},{"location":"syntaxhighlight/#notepad","text":"Note Dark mode only This syntax highlighter is included with Angel mod, you can find it in the syntax folder. Auto-completion support (although a little bit messy)","title":"Notepad++"},{"location":"syntaxhighlight/#installation","text":"Go to in Notepad++ Language->User Defined Language->Open User Defined Language folder... place angelscript_wj.xml there. Go to C:\\Notepad++\\autoCompletion\\ place angelscript_wj.xml there from the autoCompletion zip's folder. Go to C:\\Notepad++\\functionList\\ place angelscript_wj.xml there from the functionList zip's folder. Restart Notepad++. Notepad++ should now recognize *.as files.","title":"Installation"},{"location":"syntaxhighlight/#visual-studio-code","text":"TODO","title":"Visual Studio Code"},{"location":"usage/","text":"Using AngelScript \uf0c1 Important AngelScript commands: Debugging: (These might or might not be useful for script writers) wj_angelscript_debug Enable or disable the entire logging of AngelScript to the console. (Default: 1) wj_angelscript_debug_info Enable or disable the INFO logging during compilation of AngelScript to the console. (Default: 1) wj_angelscript_debug_warn Enable or disable the WARN logging during compilation of AngelScript to the console. (Default: 1) wj_angelscript_debug_script_warn Enable or disable AngelScript script warnings. (Default: 1) wj_angelscript_debug_scriptobj Enable or disable GetScriptObj logging to the console. (Default: 0) wj_angelscript_debug_cache Prints out debug information for cache. (Default: 0) wj_angelscript_debug_precache Prints out debug information for Precaching functions. (Default: 0) wj_angelscript_debug_console Brings out the console the moment a red error was logged. (Default: 0) wj_angelscript_debug_log Saves every kind of AngelScript log to file called !angelscript_log.txt . (Default: 1) Dumping: (For misc. purposes) wj_angelscript_dump Dumps out information about AngelScript. (engine, module, functions, methods, etc...) wj_angelscript_dump_behaviors Whether to dump out Object type's behavior to the console or not. (Default: 0) wj_angelscript_dump_docs Dumps out information about AngelScript in a way that's format-friendly for Docs. wj_angelscript_dump_docs_globalfuncnames Should it also dump out global function's name, or not. (Default: 1) wj_angelscript_dump_script Dumps out information about user written scripts. (from !as_scripts.txt) wj_angelscript_dump_script_class_methods Should it dump out the methods of script classes, or not. (Default: 0) wj_angelscript_dump_script_class_properties Should it dump out the properties (variables) of script classes, or not. (Default: 0) wj_angelscript_dump_syntax Dumps out information about all the global functions, the object types and their functions, variables without declaration. wj_angelscript_dump_syntax_npp_xml Dumps out all the hardcoded object types, global functions, their names and declarations to a Notepad++ AutoCompletion file. wj_angelscript_debug_typeid Dumps out the typeids for variable types. Only useful for programmers. wj_angelscript_debug_array <datatype> Dumps out information about this specific array. I.e. CP3SObj@ General: wj_angelscript_enabled Enable or disable AngelScript completely. (Default: 1) wj_angelscript_recompile Recompile AngelScript files included from '!as_scripts.txt', memory is purged. wj_angelscript_recompile_alt Same as wj_angelscript_recompile , but the console is cleared out before printing out AngelScript log. wj_angelscript_test Call 'Test' function in class 'bh_player', used to debug AngelScript functions and execute them easily. wj_angelscript_test2 Call 'Test2' function in class 'bh_player', used to debug AngelScript functions and execute them easily. wj_angelscript_test_example Call 'Test3' function in class 'bh_player', used to debug AngelScript functions and execute them easily. wj_angelscript_exec <class> <function> Executes AngelScript with a class and function name globally. AngelScript's main script file is located at '../%gameFolder%/scripts/AngelScript/!as_scripts.txt' %gameFolder% is the mod folder loaded with the -game param, for CR it is called cr_base . Example: '../cr_base/scripts/AngelScript/!as_scripts.txt' In !as_scripts.txt you include all the files you want the game to load during compilation (this could be game start, load, or by forcing the game to recompile via wj_angelscript_recompile cheat command) Example: #include \"enums.as\" #include \"Utils.as\" #include \"WantedReinforcement.as\" #include \"bh_player.as\" #include \"bh_npc_citizen.as\" #include \"engine.as\" //#include \"misc/tools.as\" In Postal3Script you can call any AngelScript function via the AngelScript P3S function. (Angel/CR only) Syntaxes: AngelScript \"Object:<pointer> <className> <functionName>\" AngelScript \"Object:<pointer> <functionName>\" (Note: <className> will be the entity's current P3S behavior) In Postal3Script: xpt_randomizeState { actions { AngelScript \"Object:self Utils RandomizeState\" } } In AngelScript: class Utils : IPostal3Script { CP3SObj@ self; CUtils(CP3SObj@ obj) { @self = @obj; } void RandomizeState() { if (self == null) return; int iState = RandomInt(0,2); switch (iState) { case 0: self.State(\"st_idle\"); break; case 1: self.State(\"st_sit\"); break; case 2: self.State(\"st_rest\"); break; } } } Hardcoded Classes and it's Functions \uf0c1 The Hardcoded Classes and it's functions can be found in the engine.as file. (In Catharsis Reborn, atleast.) 'Player' class: Event_Killed(CTakeDamageInfo@ info) OnTakeDamage(CTakeDamageInfo@ info) OnWantedStarGain (CR only) OnWantedStarReduction (CR only) OnWantedStarSet (CR only) OnRestore -- (Transition, Save game load) OnWantedClear (CR only) OnWantedGain (CR only) OnWantedReduction (CR only) OnWeaponDeployOnce (CR only) OnSpecialAmmoPickup (CR only) OnAmmoPickup (CR only) OnHostageTaken OnHostageReleased_Killed OnHostageReleased_Kicked (CR only) OnNPCArrested OnOutOfBoundary -- (When Player's ragdoll touches a Player clip) (CR only) 'NPC' class: (this class is shared with ALL NPC types) Event_Killed(CTakeDamageInfo@ info) OnTakeDamage(CTakeDamageInfo@ info) Event_Unconscious(CTakeDamageInfo@ info) OnCrawling (CR only) OnTakeDamage_Alive(CTakeDamageInfo@ info) OnTakeDamage_Dying(CTakeDamageInfo@ info) 'SEngine' class: LevelInitPostEntity -- (entities are created / spawned / precached here) LevelInitPreEntity -- (Level loaded, but before entities spawned in) LevelShutdownPostEntity -- (Level completely shut down, no entities here) LevelShutdownPreEntity -- (Level not yet shut down, entities are still here) OnRestore -- (Level fully loaded, transition or load game) OnSave -- (Player/server saved the game) Recompile -- (Whenever the scripts are recompiled) PostInit -- (Called when the game starts up and AngelScript successfully compiled) FireGameEvent(CGameEvent@ evt) -- (Whenever a game event is fired and has been registered) OnCVarChanged(string name, string OldString, float OldValue) -- (Whenever a cvar that was manipulated inside AngelScript was changed) OnDoorDestroyed(string name, Vector pos) -- (Whenever a door is destroyed) (CR only) OnDoorSpawned(string name, CBaseEntity@ door) -- (Whenever a door is spawned) (CR only) 'FSMProp' class: (CR only) OnInventoryItemPreSpawn(int type, CBaseEntity@ ptr) -- (When an inventory item is not yet fully spawned) OnInventoryItemSpawn(int type, CBaseEntity@ ptr) -- (When an inventory item is just yet to be spawned)","title":"Using AngelScript"},{"location":"usage/#using-angelscript","text":"Important AngelScript commands: Debugging: (These might or might not be useful for script writers) wj_angelscript_debug Enable or disable the entire logging of AngelScript to the console. (Default: 1) wj_angelscript_debug_info Enable or disable the INFO logging during compilation of AngelScript to the console. (Default: 1) wj_angelscript_debug_warn Enable or disable the WARN logging during compilation of AngelScript to the console. (Default: 1) wj_angelscript_debug_script_warn Enable or disable AngelScript script warnings. (Default: 1) wj_angelscript_debug_scriptobj Enable or disable GetScriptObj logging to the console. (Default: 0) wj_angelscript_debug_cache Prints out debug information for cache. (Default: 0) wj_angelscript_debug_precache Prints out debug information for Precaching functions. (Default: 0) wj_angelscript_debug_console Brings out the console the moment a red error was logged. (Default: 0) wj_angelscript_debug_log Saves every kind of AngelScript log to file called !angelscript_log.txt . (Default: 1) Dumping: (For misc. purposes) wj_angelscript_dump Dumps out information about AngelScript. (engine, module, functions, methods, etc...) wj_angelscript_dump_behaviors Whether to dump out Object type's behavior to the console or not. (Default: 0) wj_angelscript_dump_docs Dumps out information about AngelScript in a way that's format-friendly for Docs. wj_angelscript_dump_docs_globalfuncnames Should it also dump out global function's name, or not. (Default: 1) wj_angelscript_dump_script Dumps out information about user written scripts. (from !as_scripts.txt) wj_angelscript_dump_script_class_methods Should it dump out the methods of script classes, or not. (Default: 0) wj_angelscript_dump_script_class_properties Should it dump out the properties (variables) of script classes, or not. (Default: 0) wj_angelscript_dump_syntax Dumps out information about all the global functions, the object types and their functions, variables without declaration. wj_angelscript_dump_syntax_npp_xml Dumps out all the hardcoded object types, global functions, their names and declarations to a Notepad++ AutoCompletion file. wj_angelscript_debug_typeid Dumps out the typeids for variable types. Only useful for programmers. wj_angelscript_debug_array <datatype> Dumps out information about this specific array. I.e. CP3SObj@ General: wj_angelscript_enabled Enable or disable AngelScript completely. (Default: 1) wj_angelscript_recompile Recompile AngelScript files included from '!as_scripts.txt', memory is purged. wj_angelscript_recompile_alt Same as wj_angelscript_recompile , but the console is cleared out before printing out AngelScript log. wj_angelscript_test Call 'Test' function in class 'bh_player', used to debug AngelScript functions and execute them easily. wj_angelscript_test2 Call 'Test2' function in class 'bh_player', used to debug AngelScript functions and execute them easily. wj_angelscript_test_example Call 'Test3' function in class 'bh_player', used to debug AngelScript functions and execute them easily. wj_angelscript_exec <class> <function> Executes AngelScript with a class and function name globally. AngelScript's main script file is located at '../%gameFolder%/scripts/AngelScript/!as_scripts.txt' %gameFolder% is the mod folder loaded with the -game param, for CR it is called cr_base . Example: '../cr_base/scripts/AngelScript/!as_scripts.txt' In !as_scripts.txt you include all the files you want the game to load during compilation (this could be game start, load, or by forcing the game to recompile via wj_angelscript_recompile cheat command) Example: #include \"enums.as\" #include \"Utils.as\" #include \"WantedReinforcement.as\" #include \"bh_player.as\" #include \"bh_npc_citizen.as\" #include \"engine.as\" //#include \"misc/tools.as\" In Postal3Script you can call any AngelScript function via the AngelScript P3S function. (Angel/CR only) Syntaxes: AngelScript \"Object:<pointer> <className> <functionName>\" AngelScript \"Object:<pointer> <functionName>\" (Note: <className> will be the entity's current P3S behavior) In Postal3Script: xpt_randomizeState { actions { AngelScript \"Object:self Utils RandomizeState\" } } In AngelScript: class Utils : IPostal3Script { CP3SObj@ self; CUtils(CP3SObj@ obj) { @self = @obj; } void RandomizeState() { if (self == null) return; int iState = RandomInt(0,2); switch (iState) { case 0: self.State(\"st_idle\"); break; case 1: self.State(\"st_sit\"); break; case 2: self.State(\"st_rest\"); break; } } }","title":"Using AngelScript"},{"location":"usage/#hardcoded-classes-and-its-functions","text":"The Hardcoded Classes and it's functions can be found in the engine.as file. (In Catharsis Reborn, atleast.) 'Player' class: Event_Killed(CTakeDamageInfo@ info) OnTakeDamage(CTakeDamageInfo@ info) OnWantedStarGain (CR only) OnWantedStarReduction (CR only) OnWantedStarSet (CR only) OnRestore -- (Transition, Save game load) OnWantedClear (CR only) OnWantedGain (CR only) OnWantedReduction (CR only) OnWeaponDeployOnce (CR only) OnSpecialAmmoPickup (CR only) OnAmmoPickup (CR only) OnHostageTaken OnHostageReleased_Killed OnHostageReleased_Kicked (CR only) OnNPCArrested OnOutOfBoundary -- (When Player's ragdoll touches a Player clip) (CR only) 'NPC' class: (this class is shared with ALL NPC types) Event_Killed(CTakeDamageInfo@ info) OnTakeDamage(CTakeDamageInfo@ info) Event_Unconscious(CTakeDamageInfo@ info) OnCrawling (CR only) OnTakeDamage_Alive(CTakeDamageInfo@ info) OnTakeDamage_Dying(CTakeDamageInfo@ info) 'SEngine' class: LevelInitPostEntity -- (entities are created / spawned / precached here) LevelInitPreEntity -- (Level loaded, but before entities spawned in) LevelShutdownPostEntity -- (Level completely shut down, no entities here) LevelShutdownPreEntity -- (Level not yet shut down, entities are still here) OnRestore -- (Level fully loaded, transition or load game) OnSave -- (Player/server saved the game) Recompile -- (Whenever the scripts are recompiled) PostInit -- (Called when the game starts up and AngelScript successfully compiled) FireGameEvent(CGameEvent@ evt) -- (Whenever a game event is fired and has been registered) OnCVarChanged(string name, string OldString, float OldValue) -- (Whenever a cvar that was manipulated inside AngelScript was changed) OnDoorDestroyed(string name, Vector pos) -- (Whenever a door is destroyed) (CR only) OnDoorSpawned(string name, CBaseEntity@ door) -- (Whenever a door is spawned) (CR only) 'FSMProp' class: (CR only) OnInventoryItemPreSpawn(int type, CBaseEntity@ ptr) -- (When an inventory item is not yet fully spawned) OnInventoryItemSpawn(int type, CBaseEntity@ ptr) -- (When an inventory item is just yet to be spawned)","title":"Hardcoded Classes and it's Functions"},{"location":"datatypes/angularimpulse/","text":"AngularImpulse \uf0c1 Properties \uf0c1 float x -- Gets the X coordinate float y -- Gets the Y coordinate float z -- Gets the Z coordinate Declaration \uf0c1 AngularImpulse ang; AngularImpulse ang(x,y,z); AngularImpulse ang = AngularImpulse(x,y,z);","title":"AngularImpulse"},{"location":"datatypes/angularimpulse/#angularimpulse","text":"","title":"AngularImpulse"},{"location":"datatypes/angularimpulse/#properties","text":"float x -- Gets the X coordinate float y -- Gets the Y coordinate float z -- Gets the Z coordinate","title":"Properties"},{"location":"datatypes/angularimpulse/#declaration","text":"AngularImpulse ang; AngularImpulse ang(x,y,z); AngularImpulse ang = AngularImpulse(x,y,z);","title":"Declaration"},{"location":"datatypes/array/","text":"array (native) \uf0c1 Methods (WJ) \uf0c1 T random() -- Gets a random element from the array. Methods (native) \uf0c1 uint length() const -- Returns the length of the array. void resize(uint) -- Sets the new length of the array. void reverse() -- Reverses the order of the elements in the array. void insertAt(uint index, const T& in value) void insertAt(uint index, const array<T>& arr) -- Inserts a new element, or another array of elements, into the array at the specified index. void insertLast(const T& in) -- Appends an element at the end of the array. void removeAt(uint index) -- Removes the element at the specified index. void removeLast() -- Removes the last element of the array. void removeRange(uint start, uint count) -- Removes count elements starting from start. void sortAsc() void sortAsc(uint startAt, uint count) -- Sorts the elements in the array in ascending order. For object types, this will use the type's opCmp method. The second variant will sort only the elements starting at index startAt and the following count elements. void sortDesc() void sortDesc(uint startAt, uint count) -- These does the same thing as sortAsc except sorts the elements in descending order. void sort(const less &in compareFunc, uint startAt = 0, uint count = uint(-1)) -- This method takes as input a callback function to use for comparing two elements when sorting the array. int find(const T& in) int find(uint startAt, const T& in) -- These will return the index of the first element that has the same value as the wanted value. int findByRef(const T& in) int findByRef(uint startAt, const T& in) -- These will search for a matching address. These are especially useful for arrays of handles where specific instances of objects are desired, and not just objects that happen to have equal value. If no match is found the methods will return a negative value. uint size() const bool empty() const void push_back(const T&in) void pop_back() void insert(uint index, const T&in value) void insert(uint index, const array<T>& arr) void erase(uint) void reserve(uint length) Declaration \uf0c1 array<int> a; array<string> s; array<CBaseEntity@> ents; array<MyClassName@> cn; array<int> a, b, c; array<Foo@> d; array<int> a; // A zero-length array of integers array<int> b(3); // An array of integers with 3 elements array<int> c(3, 1); // An array of integers with 3 elements, all set to 1 by default array<int> d = {5,6,7}; // An array of integers with 3 elements with specific values array<array<int>> a; // An empty array of arrays of integers array<array<int>> b = {{1,2},{3,4}} // A 2 by 2 array with initialized values array<array<int>> c(10, array<int>(10)); // A 10 by 10 array of integers with uninitialized values","title":"array (native)"},{"location":"datatypes/array/#array-native","text":"","title":"array (native)"},{"location":"datatypes/array/#methods-wj","text":"T random() -- Gets a random element from the array.","title":"Methods (WJ)"},{"location":"datatypes/array/#methods-native","text":"uint length() const -- Returns the length of the array. void resize(uint) -- Sets the new length of the array. void reverse() -- Reverses the order of the elements in the array. void insertAt(uint index, const T& in value) void insertAt(uint index, const array<T>& arr) -- Inserts a new element, or another array of elements, into the array at the specified index. void insertLast(const T& in) -- Appends an element at the end of the array. void removeAt(uint index) -- Removes the element at the specified index. void removeLast() -- Removes the last element of the array. void removeRange(uint start, uint count) -- Removes count elements starting from start. void sortAsc() void sortAsc(uint startAt, uint count) -- Sorts the elements in the array in ascending order. For object types, this will use the type's opCmp method. The second variant will sort only the elements starting at index startAt and the following count elements. void sortDesc() void sortDesc(uint startAt, uint count) -- These does the same thing as sortAsc except sorts the elements in descending order. void sort(const less &in compareFunc, uint startAt = 0, uint count = uint(-1)) -- This method takes as input a callback function to use for comparing two elements when sorting the array. int find(const T& in) int find(uint startAt, const T& in) -- These will return the index of the first element that has the same value as the wanted value. int findByRef(const T& in) int findByRef(uint startAt, const T& in) -- These will search for a matching address. These are especially useful for arrays of handles where specific instances of objects are desired, and not just objects that happen to have equal value. If no match is found the methods will return a negative value. uint size() const bool empty() const void push_back(const T&in) void pop_back() void insert(uint index, const T&in value) void insert(uint index, const array<T>& arr) void erase(uint) void reserve(uint length)","title":"Methods (native)"},{"location":"datatypes/array/#declaration","text":"array<int> a; array<string> s; array<CBaseEntity@> ents; array<MyClassName@> cn; array<int> a, b, c; array<Foo@> d; array<int> a; // A zero-length array of integers array<int> b(3); // An array of integers with 3 elements array<int> c(3, 1); // An array of integers with 3 elements, all set to 1 by default array<int> d = {5,6,7}; // An array of integers with 3 elements with specific values array<array<int>> a; // An empty array of arrays of integers array<array<int>> b = {{1,2},{3,4}} // A 2 by 2 array with initialized values array<array<int>> c(10, array<int>(10)); // A 10 by 10 array of integers with uninitialized values","title":"Declaration"},{"location":"datatypes/qangle/","text":"QAngle \uf0c1 Properties \uf0c1 float x -- Gets the X coordinate float y -- Gets the Y coordinate float z -- Gets the Z coordinate Declaration \uf0c1 QAngle ang; QAngle ang(x,y,z); QAngle ang = QAngle(x,y,z);","title":"QAngle"},{"location":"datatypes/qangle/#qangle","text":"","title":"QAngle"},{"location":"datatypes/qangle/#properties","text":"float x -- Gets the X coordinate float y -- Gets the Y coordinate float z -- Gets the Z coordinate","title":"Properties"},{"location":"datatypes/qangle/#declaration","text":"QAngle ang; QAngle ang(x,y,z); QAngle ang = QAngle(x,y,z);","title":"Declaration"},{"location":"datatypes/string/","text":"string (native) \uf0c1 AngelScript's native string datatype was extended. Declaration (WJ) \uf0c1 string str(\"%s\", ...) -- Creates the string with formatting, vars go up to 15. Example: string a = \"abc\"; string b = \"def\"; string c(\"%s%s\", a, b); // this will be 'abcdef' once constructed. Printf(\"%s\\n\", c); // This will print 'abcdef' to the console. Declaration (native) \uf0c1 string str(str2) -- Copies a string to be used for construction. Methods (WJ) \uf0c1 void toLower() -- Turns all characters to lower. void toUpper() -- Turns all characters to upper. void toReverse() -- Reverses the casing of all the characters. void format(string &in, ...) -- Formats the string, vars go up to 15. Methods (native) \uf0c1 uint length() const -- Returns the length of the string. void resize(uint) -- Sets the length of the string. bool isEmpty() const -- Returns true if the string is empty, i.e. the length is zero. string substr(uint start = 0, int count = -1) const -- Returns a string with the content starting at start and the number of bytes given by count. The default arguments will return the whole string as the new string. void insert(uint pos, const string &in other) -- Inserts another string other at position pos in the original string. void erase(uint pos, int count = -1) -- Erases a range of characters from the string, starting at position pos and counting count characters. int findFirst(const string &in str, uint start = 0) const -- Find the first occurrence of the value str in the string, starting at start. If no occurrence is found a negative value will be returned. int findLast(const string &in str, int start = -1) const -- Find the last occurrence of the value str in the string. If start is informed the search will begin at that position, i.e. any potential occurrence after that position will not be searched. If no occurrence is found a negative value will be returned. int findFirstOf(const string &in chars, int start = 0) const int findFirstNotOf(const string &in chars, int start = 0) const int findLastOf(const string &in chars, int start = -1) const int findLastNotOf(const string &in chars, int start = -1) const The first variant finds the first character in the string that matches on of the characters in chars, starting at start. If no occurrence is found a negative value will be returned. The second variant finds the first character that doesn't match any of those in chars. The third and last variant are the same except they start the search from the end of the string. Functions (native) \uf0c1 array<string>@ split(const string &in delimiter) const -- Splits the string in smaller strings where the delimiter is found. int64 parseInt(const string &in str, uint base = 10, uint &out byteCount = 0) uint64 parseUInt(const string &in str, uint base = 10, uint &out byteCount = 0) -- Parses the string for an integer value. The base can be 10 or 16 to support decimal numbers or hexadecimal numbers. If byteCount is provided it will be set to the number of bytes that were considered as part of the integer value. double parseFloat(const string &in, uint &out byteCount = 0) -- Parses the string for a floating point value. If byteCount is provided it will be set to the number of bytes that were considered as part of the value. string formatInt(int64 val, const string &in options = '', uint width = 0) string formatUInt(uint64 val, const string &in options = '', uint width = 0) string formatFloat(double val, const string &in options = '', uint width = 0, uint precision = 0) The format functions takes a string that defines how the number should be formatted. The string is a combination of the following characters: 'l' = left justify '0' = pad with zeroes '+' = always include the sign, even if positive 'space' = add a space in case of positive number 'h' = hexadecimal integer small letters (not valid for formatFloat) 'H' = hexadecimal integer capital letters (not valid for formatFloat) 'e' = exponent character with small e (only valid for formatFloat) 'E' = exponent character with capital E (only valid for formatFloat) Example: // Left justify number in string with 10 characters string justified = formatInt(number, 'l', 10); // Create hexadecimal representation with capital letters, right justified string hex = formatInt(number, 'H', 10); // Right justified, padded with zeroes and two digits after decimal separator string num = formatFloat(number, '0', 8, 2);","title":"string (native)"},{"location":"datatypes/string/#string-native","text":"AngelScript's native string datatype was extended.","title":"string (native)"},{"location":"datatypes/string/#declaration-wj","text":"string str(\"%s\", ...) -- Creates the string with formatting, vars go up to 15. Example: string a = \"abc\"; string b = \"def\"; string c(\"%s%s\", a, b); // this will be 'abcdef' once constructed. Printf(\"%s\\n\", c); // This will print 'abcdef' to the console.","title":"Declaration (WJ)"},{"location":"datatypes/string/#declaration-native","text":"string str(str2) -- Copies a string to be used for construction.","title":"Declaration (native)"},{"location":"datatypes/string/#methods-wj","text":"void toLower() -- Turns all characters to lower. void toUpper() -- Turns all characters to upper. void toReverse() -- Reverses the casing of all the characters. void format(string &in, ...) -- Formats the string, vars go up to 15.","title":"Methods (WJ)"},{"location":"datatypes/string/#methods-native","text":"uint length() const -- Returns the length of the string. void resize(uint) -- Sets the length of the string. bool isEmpty() const -- Returns true if the string is empty, i.e. the length is zero. string substr(uint start = 0, int count = -1) const -- Returns a string with the content starting at start and the number of bytes given by count. The default arguments will return the whole string as the new string. void insert(uint pos, const string &in other) -- Inserts another string other at position pos in the original string. void erase(uint pos, int count = -1) -- Erases a range of characters from the string, starting at position pos and counting count characters. int findFirst(const string &in str, uint start = 0) const -- Find the first occurrence of the value str in the string, starting at start. If no occurrence is found a negative value will be returned. int findLast(const string &in str, int start = -1) const -- Find the last occurrence of the value str in the string. If start is informed the search will begin at that position, i.e. any potential occurrence after that position will not be searched. If no occurrence is found a negative value will be returned. int findFirstOf(const string &in chars, int start = 0) const int findFirstNotOf(const string &in chars, int start = 0) const int findLastOf(const string &in chars, int start = -1) const int findLastNotOf(const string &in chars, int start = -1) const The first variant finds the first character in the string that matches on of the characters in chars, starting at start. If no occurrence is found a negative value will be returned. The second variant finds the first character that doesn't match any of those in chars. The third and last variant are the same except they start the search from the end of the string.","title":"Methods (native)"},{"location":"datatypes/string/#functions-native","text":"array<string>@ split(const string &in delimiter) const -- Splits the string in smaller strings where the delimiter is found. int64 parseInt(const string &in str, uint base = 10, uint &out byteCount = 0) uint64 parseUInt(const string &in str, uint base = 10, uint &out byteCount = 0) -- Parses the string for an integer value. The base can be 10 or 16 to support decimal numbers or hexadecimal numbers. If byteCount is provided it will be set to the number of bytes that were considered as part of the integer value. double parseFloat(const string &in, uint &out byteCount = 0) -- Parses the string for a floating point value. If byteCount is provided it will be set to the number of bytes that were considered as part of the value. string formatInt(int64 val, const string &in options = '', uint width = 0) string formatUInt(uint64 val, const string &in options = '', uint width = 0) string formatFloat(double val, const string &in options = '', uint width = 0, uint precision = 0) The format functions takes a string that defines how the number should be formatted. The string is a combination of the following characters: 'l' = left justify '0' = pad with zeroes '+' = always include the sign, even if positive 'space' = add a space in case of positive number 'h' = hexadecimal integer small letters (not valid for formatFloat) 'H' = hexadecimal integer capital letters (not valid for formatFloat) 'e' = exponent character with small e (only valid for formatFloat) 'E' = exponent character with capital E (only valid for formatFloat) Example: // Left justify number in string with 10 characters string justified = formatInt(number, 'l', 10); // Create hexadecimal representation with capital letters, right justified string hex = formatInt(number, 'H', 10); // Right justified, padded with zeroes and two digits after decimal separator string num = formatFloat(number, '0', 8, 2);","title":"Functions (native)"},{"location":"datatypes/string_t/","text":"string_t \uf0c1 Warning This datatype will lose it's value after a level change, it is recommended to use native string for data storage. Otherwise you need to reinitialize it's value everytime the Player enters a new level. (either through transition, load, or new game) Todo Serialization might fix this issue? Methods \uf0c1 string ToString() -- Converts string_t value to string value. Declaration \uf0c1 string_t str; string_t str = \"text\"; string_t str(\"text\"); string_t str = string_str; // string string_t str = string_t_str; // string_t string_t str(string_str); string_t str(string_t_str);","title":"string_t"},{"location":"datatypes/string_t/#string_t","text":"Warning This datatype will lose it's value after a level change, it is recommended to use native string for data storage. Otherwise you need to reinitialize it's value everytime the Player enters a new level. (either through transition, load, or new game) Todo Serialization might fix this issue?","title":"string_t"},{"location":"datatypes/string_t/#methods","text":"string ToString() -- Converts string_t value to string value.","title":"Methods"},{"location":"datatypes/string_t/#declaration","text":"string_t str; string_t str = \"text\"; string_t str(\"text\"); string_t str = string_str; // string string_t str = string_t_str; // string_t string_t str(string_str); string_t str(string_t_str);","title":"Declaration"},{"location":"datatypes/vector/","text":"Vector \uf0c1 Tip You can use VectorNormalize to normalize vectors. Properties \uf0c1 float x -- Gets the X coordinate float y -- Gets the Y coordinate float z -- Gets the Z coordinate Declaration \uf0c1 Vector vec; Vector vec(x,y,z); Vector vec = Vector(x,y,z); Vector vec = Vector(x,y,z) - Vector(x,y,z); Methods \uf0c1 void NormalizeInPlace() Functions \uf0c1 float VectorNormalize(Vector& vec) float DotProduct(Vector vec1, Vector vec2) void AngleVectors(QAngle ang, Vector& forward, Vector& right, Vector& up) Example \uf0c1 // Normalizes the vector for the helicopter Vector dir = nextpatrol.GetAbsOrigin() - self.GetBaseEntity().GetAbsOrigin(); VectorNormalize(dir); // This function is used to determine if the activator is facing the register // 'self' is the register here bool IsFacingRegister(CP3SObj@ Whom) { Vector tempRight, tempUp; // Get a vector from owner origin to target origin Vector vecToTarget; vecToTarget = Whom.GetBaseEntity().WorldSpaceCenter() - self.GetBaseEntity().WorldSpaceCenter(); vecToTarget.z = 0.0f; vecToTarget.NormalizeInPlace(); // Get owner forward view vector Vector vecOwnerForward; AngleVectors( self.GetBaseEntity().EyeAngles(), vecOwnerForward, tempRight, tempUp ); vecOwnerForward.z = 0.0f; vecOwnerForward.NormalizeInPlace(); float flPosVsOwnerViewDot = DotProduct( vecToTarget, vecOwnerForward ); // Facing? if (flPosVsOwnerViewDot > 0.25f) { Printf(\"Facing the cash register!\\n\"); return true; } return false; }","title":"Vector"},{"location":"datatypes/vector/#vector","text":"Tip You can use VectorNormalize to normalize vectors.","title":"Vector"},{"location":"datatypes/vector/#properties","text":"float x -- Gets the X coordinate float y -- Gets the Y coordinate float z -- Gets the Z coordinate","title":"Properties"},{"location":"datatypes/vector/#declaration","text":"Vector vec; Vector vec(x,y,z); Vector vec = Vector(x,y,z); Vector vec = Vector(x,y,z) - Vector(x,y,z);","title":"Declaration"},{"location":"datatypes/vector/#methods","text":"void NormalizeInPlace()","title":"Methods"},{"location":"datatypes/vector/#functions","text":"float VectorNormalize(Vector& vec) float DotProduct(Vector vec1, Vector vec2) void AngleVectors(QAngle ang, Vector& forward, Vector& right, Vector& up)","title":"Functions"},{"location":"datatypes/vector/#example","text":"// Normalizes the vector for the helicopter Vector dir = nextpatrol.GetAbsOrigin() - self.GetBaseEntity().GetAbsOrigin(); VectorNormalize(dir); // This function is used to determine if the activator is facing the register // 'self' is the register here bool IsFacingRegister(CP3SObj@ Whom) { Vector tempRight, tempUp; // Get a vector from owner origin to target origin Vector vecToTarget; vecToTarget = Whom.GetBaseEntity().WorldSpaceCenter() - self.GetBaseEntity().WorldSpaceCenter(); vecToTarget.z = 0.0f; vecToTarget.NormalizeInPlace(); // Get owner forward view vector Vector vecOwnerForward; AngleVectors( self.GetBaseEntity().EyeAngles(), vecOwnerForward, tempRight, tempUp ); vecOwnerForward.z = 0.0f; vecOwnerForward.NormalizeInPlace(); float flPosVsOwnerViewDot = DotProduct( vecToTarget, vecOwnerForward ); // Facing? if (flPosVsOwnerViewDot > 0.25f) { Printf(\"Facing the cash register!\\n\"); return true; } return false; }","title":"Example"},{"location":"enums/hintignorefacing_t/","text":"HintIgnoreFacing_t \uf0c1 Note This enum is hardcoded inside AngelScript. You don't need to copy paste this into a file! //########################################################### // >> HintNodeData // // This is a chunk of data that's passed to a hint node entity // when it's created from a CNodeEnt. //########################################################### enum HintIgnoreFacing_t { HIF_NO, HIF_YES, HIF_DEFAULT, };","title":"HintIgnoreFacing_t"},{"location":"enums/hintignorefacing_t/#hintignorefacing_t","text":"Note This enum is hardcoded inside AngelScript. You don't need to copy paste this into a file! //########################################################### // >> HintNodeData // // This is a chunk of data that's passed to a hint node entity // when it's created from a CNodeEnt. //########################################################### enum HintIgnoreFacing_t { HIF_NO, HIF_YES, HIF_DEFAULT, };","title":"HintIgnoreFacing_t"},{"location":"enums/npc_state/","text":"NPC_STATE \uf0c1 Note This enum is hardcoded inside AngelScript. You don't need to copy paste this into a file! enum NPC_STATE { NPC_STATE_INVALID = -1, NPC_STATE_NONE = 0, NPC_STATE_IDLE, NPC_STATE_ALERT, NPC_STATE_COMBAT, NPC_STATE_SCRIPT, NPC_STATE_PLAYDEAD, NPC_STATE_PRONE, // When in clutches of barnacle NPC_STATE_DEAD };","title":"NPC_STATE"},{"location":"enums/npc_state/#npc_state","text":"Note This enum is hardcoded inside AngelScript. You don't need to copy paste this into a file! enum NPC_STATE { NPC_STATE_INVALID = -1, NPC_STATE_NONE = 0, NPC_STATE_IDLE, NPC_STATE_ALERT, NPC_STATE_COMBAT, NPC_STATE_SCRIPT, NPC_STATE_PLAYDEAD, NPC_STATE_PRONE, // When in clutches of barnacle NPC_STATE_DEAD };","title":"NPC_STATE"},{"location":"example/areaevent/","text":"AreaEvent ported to AngelScript \uf0c1 The code below is identical to how Postal3Script's AreaEvent work. Copy and paste them into your code, you can then call these functions with the filtered version, or without filtering! Filtered version \uf0c1 void AreaEvent(CP3SObj@ center, string EventName, float Radius, array<string> Filter) { Radius = Radius * 32; EventName.insert(0, \"OnAE_\"); array<CP3SObj@> aNPC = engine.GetArrayOfEntitiesRadius(@center, Radius); for (uint i = 0; i < aNPC.length(); i++) { if ( aNPC[i] == null ) continue; if ( aNPC[i] == @center ) continue; bool bFire = false; for (uint j = 0; j < Filter.length(); j++) { string sFilter = Filter[j]; sFilter.toLower(); string Manner = aNPC[i].GetManner(); Manner.toLower(); string Faction = aNPC[i].GetFaction(); Faction.toLower(); string State = aNPC[i].GetCurState(); State.toLower(); if ( Manner == sFilter || Faction == sFilter || State == sFilter ) { bFire = true; break; } } if (bFire) aNPC[i].FireEvent(EventName, center); } } Non-Filtered version \uf0c1 void AreaEvent(CP3SObj@ center, string EventName, float Radius) { Radius = Radius * 32; EventName.insert(0, \"OnAE_\"); array<CP3SObj@> aNPC = engine.GetArrayOfEntitiesRadius(@center, Radius); for (uint i = 0; i < aNPC.length(); i++) { if ( aNPC[i] == null ) continue; if ( aNPC[i] == @center ) continue; aNPC[i].FireEvent(EventName, center); } } Example (How to use) \uf0c1 Put the AreaEvent functions into a non-class AngelScript file, i.e. utils.as , and include it in your file you wish to use the functions from. You can also just put it into a class, but it's generally a good idea to make your code clean. For this example I'm going to assume I have already put the code into utils.as . In the example below, all the objects will have OnAE_MyAreaEvent called on them, with the caller being the executioner. You can modify who the executioner is by using the first argument, so instead of self it could also be self.GetTarget() , of course if it exists in the first place ... #include \"Utils.as\" class MyClass : IPostal3Script { void MyFunction() { CP3SObj @self = GetContextOwner(); if ( @self == null ) return; // There are 2 ways of using the Filtered version: // 1.) Putting the string array directly into the function AreaEvent( self, \"MyAreaEvent\", 8, {\"Animals\", \"st_idle\", \"PussyCat\"} ); // 2.) Creating a string array, then putting the array into the function // Doing this is much more recommended, since you can easily swap out strings // and can also turn this into something dynamic array<string> Filter = { \"Animals\", \"st_idle\", \"PussyCat\" }; AreaEvent( self, \"MyAreaEvent\", 8, Filter ); ///////////////////////////////////////////////////////////////////////// // Non-filtered function will call this event on all nearby objects: AreaEvent( self, \"MyAreaEvent\", 8 ); } }","title":"Ported AreaEvent"},{"location":"example/areaevent/#areaevent-ported-to-angelscript","text":"The code below is identical to how Postal3Script's AreaEvent work. Copy and paste them into your code, you can then call these functions with the filtered version, or without filtering!","title":"AreaEvent ported to AngelScript"},{"location":"example/areaevent/#filtered-version","text":"void AreaEvent(CP3SObj@ center, string EventName, float Radius, array<string> Filter) { Radius = Radius * 32; EventName.insert(0, \"OnAE_\"); array<CP3SObj@> aNPC = engine.GetArrayOfEntitiesRadius(@center, Radius); for (uint i = 0; i < aNPC.length(); i++) { if ( aNPC[i] == null ) continue; if ( aNPC[i] == @center ) continue; bool bFire = false; for (uint j = 0; j < Filter.length(); j++) { string sFilter = Filter[j]; sFilter.toLower(); string Manner = aNPC[i].GetManner(); Manner.toLower(); string Faction = aNPC[i].GetFaction(); Faction.toLower(); string State = aNPC[i].GetCurState(); State.toLower(); if ( Manner == sFilter || Faction == sFilter || State == sFilter ) { bFire = true; break; } } if (bFire) aNPC[i].FireEvent(EventName, center); } }","title":"Filtered version"},{"location":"example/areaevent/#non-filtered-version","text":"void AreaEvent(CP3SObj@ center, string EventName, float Radius) { Radius = Radius * 32; EventName.insert(0, \"OnAE_\"); array<CP3SObj@> aNPC = engine.GetArrayOfEntitiesRadius(@center, Radius); for (uint i = 0; i < aNPC.length(); i++) { if ( aNPC[i] == null ) continue; if ( aNPC[i] == @center ) continue; aNPC[i].FireEvent(EventName, center); } }","title":"Non-Filtered version"},{"location":"example/areaevent/#example-how-to-use","text":"Put the AreaEvent functions into a non-class AngelScript file, i.e. utils.as , and include it in your file you wish to use the functions from. You can also just put it into a class, but it's generally a good idea to make your code clean. For this example I'm going to assume I have already put the code into utils.as . In the example below, all the objects will have OnAE_MyAreaEvent called on them, with the caller being the executioner. You can modify who the executioner is by using the first argument, so instead of self it could also be self.GetTarget() , of course if it exists in the first place ... #include \"Utils.as\" class MyClass : IPostal3Script { void MyFunction() { CP3SObj @self = GetContextOwner(); if ( @self == null ) return; // There are 2 ways of using the Filtered version: // 1.) Putting the string array directly into the function AreaEvent( self, \"MyAreaEvent\", 8, {\"Animals\", \"st_idle\", \"PussyCat\"} ); // 2.) Creating a string array, then putting the array into the function // Doing this is much more recommended, since you can easily swap out strings // and can also turn this into something dynamic array<string> Filter = { \"Animals\", \"st_idle\", \"PussyCat\" }; AreaEvent( self, \"MyAreaEvent\", 8, Filter ); ///////////////////////////////////////////////////////////////////////// // Non-filtered function will call this event on all nearby objects: AreaEvent( self, \"MyAreaEvent\", 8 ); } }","title":"Example (How to use)"},{"location":"example/database/","text":"Database \uf0c1 Want to save or read values but you don't want to hardcode it inside your code? With KeyValues@ you can pretty much set up a database, one where non-programmers can also set values. Here's an example: Tips The array and functions could be used globally You only need to update the \"database\" once per game Depending on the complexity of your hate system, you can easily extend it to have more checks for ex. if Player passed Monday, or if the Player did something bad in a map, and so on... You can use Manners too for a more complex behavior system (something Trashmasters started but never finished!) AngelScript: class HateFaction { // Name of our faction string self; // The factions we despise array<string> hates; } // Note: this data or array is not saved to save file, // make sure to reinitialize this on new/load game! array<HateFaction> hateFactioners; void UpdateHateDB() { // Clear out the array! hateFactioners.removeRange(0,hateFactioners.size()); KeyValues@ pData = CreateKeyValues(\"P3_Database_Thingy\"); pData.LoadFromFile(\"scripts/p3_database_thingy.txt\"); for (KeyValues@ pKV = pData.GetFirstSubKey(); pKV != null; @pKV = pKV.GetNextKey()) { // We are now inside \"entry\" //Printf(\"Key Name: %s\\n\", pKV.GetName()); // Let's look specifically for \"HateFactions\", since we do have one! KeyValues@ pSubs = pKV.FindKey(\"HateFactions\"); if (pSubs != null) { for (KeyValues@ pSub = pSubs.GetFirstSubKey(); pSub != null; @pSub = pSub.GetNextKey()) { string hater = pSub.GetName(); string hatee = pSub.GetString(); HateFaction faction; // If there's an entry for hater already, don't add it to array, // but add hater to the list! bool bFound = false; for (uint i = 0; i < hateFactioners.length(); i++) { if (hateFactioners[i].self == hater) { faction = hateFactioners[i]; bFound = true; break; } } // This is a safe check for already existing entries // We don't really need to do this but here's one as an example! if (bFound) { // We already did this once, continue looping... if (faction.hates.find(hatee) != -1) { continue; } // Not found, then add hater to list! } else { faction.self = hater; } faction.hates.insertLast(hatee); //Printf(\"Faction '%s' hates '%s'\\n\", hater, hatee); // If it's not on the array already, insert! if (!bFound) hateFactioners.insertLast(faction); } } } // it is VERY important to delete KeyValues if we don't use it anymore! pData.deleteThis(); } // Then we could check the factions like this way bool IsFactionHate(CP3SObj@ self, CP3SObj@ target) { // By default it should return false if (@self == null || @target == null) return false; string selfFaction = self.GetFaction(); string targetFaction = target.GetFaction(); for (uint i = 0; i < hateFactioners.length(); i++) { // Got our faction... if (hateFactioners[i].self == selfFaction) { // Let's iterate through self's hate list... for (uint j = 0; j < hateFactioners[i].hates.length(); j++) { // Yes, we hate this faction! if (hateFactioners[i].hates[j] == targetFaction) { return true; } } } } return false; } ... // And an example of how you could use it // (this function is inside a class which has a 'CP3SObj@ self' pointer) // (the functions and the array is in a file which is global and has been included) void SomeFunc() { if (self.GetTarget() == null) return; if (self.GetFaction() == \"Player\") return; if ( IsFactionHate(self, self.GetTarget()) ) { self.Pattern(\"pt_attack\"); } else { self.Pattern(\"pt_end\"); } } txt file in scripts folder: \"p3_database_thingy\" { \"entry\" { \"HateFactions\" { // Hater // Hatee \"Animals\" \"Citizens\" \"Animals\" \"Player\" \"Animals\" \"Police\" \"Animals\" \"Hobos\" \"Citizens\" \"Animals\" \"Police\" \"Animals\" } // Factions LIKE this Faction, they will protect them at all costs // (example of another entry for a DB thing) \"LikeFactions\" { // Liker // Liked \"Police\" \"Police\" \"Police\" \"Vendors\" \"Vendors\" \"Vendors\" \"Zealots\" \"Animals\" } } }","title":"Database"},{"location":"example/database/#database","text":"Want to save or read values but you don't want to hardcode it inside your code? With KeyValues@ you can pretty much set up a database, one where non-programmers can also set values. Here's an example: Tips The array and functions could be used globally You only need to update the \"database\" once per game Depending on the complexity of your hate system, you can easily extend it to have more checks for ex. if Player passed Monday, or if the Player did something bad in a map, and so on... You can use Manners too for a more complex behavior system (something Trashmasters started but never finished!) AngelScript: class HateFaction { // Name of our faction string self; // The factions we despise array<string> hates; } // Note: this data or array is not saved to save file, // make sure to reinitialize this on new/load game! array<HateFaction> hateFactioners; void UpdateHateDB() { // Clear out the array! hateFactioners.removeRange(0,hateFactioners.size()); KeyValues@ pData = CreateKeyValues(\"P3_Database_Thingy\"); pData.LoadFromFile(\"scripts/p3_database_thingy.txt\"); for (KeyValues@ pKV = pData.GetFirstSubKey(); pKV != null; @pKV = pKV.GetNextKey()) { // We are now inside \"entry\" //Printf(\"Key Name: %s\\n\", pKV.GetName()); // Let's look specifically for \"HateFactions\", since we do have one! KeyValues@ pSubs = pKV.FindKey(\"HateFactions\"); if (pSubs != null) { for (KeyValues@ pSub = pSubs.GetFirstSubKey(); pSub != null; @pSub = pSub.GetNextKey()) { string hater = pSub.GetName(); string hatee = pSub.GetString(); HateFaction faction; // If there's an entry for hater already, don't add it to array, // but add hater to the list! bool bFound = false; for (uint i = 0; i < hateFactioners.length(); i++) { if (hateFactioners[i].self == hater) { faction = hateFactioners[i]; bFound = true; break; } } // This is a safe check for already existing entries // We don't really need to do this but here's one as an example! if (bFound) { // We already did this once, continue looping... if (faction.hates.find(hatee) != -1) { continue; } // Not found, then add hater to list! } else { faction.self = hater; } faction.hates.insertLast(hatee); //Printf(\"Faction '%s' hates '%s'\\n\", hater, hatee); // If it's not on the array already, insert! if (!bFound) hateFactioners.insertLast(faction); } } } // it is VERY important to delete KeyValues if we don't use it anymore! pData.deleteThis(); } // Then we could check the factions like this way bool IsFactionHate(CP3SObj@ self, CP3SObj@ target) { // By default it should return false if (@self == null || @target == null) return false; string selfFaction = self.GetFaction(); string targetFaction = target.GetFaction(); for (uint i = 0; i < hateFactioners.length(); i++) { // Got our faction... if (hateFactioners[i].self == selfFaction) { // Let's iterate through self's hate list... for (uint j = 0; j < hateFactioners[i].hates.length(); j++) { // Yes, we hate this faction! if (hateFactioners[i].hates[j] == targetFaction) { return true; } } } } return false; } ... // And an example of how you could use it // (this function is inside a class which has a 'CP3SObj@ self' pointer) // (the functions and the array is in a file which is global and has been included) void SomeFunc() { if (self.GetTarget() == null) return; if (self.GetFaction() == \"Player\") return; if ( IsFactionHate(self, self.GetTarget()) ) { self.Pattern(\"pt_attack\"); } else { self.Pattern(\"pt_end\"); } } txt file in scripts folder: \"p3_database_thingy\" { \"entry\" { \"HateFactions\" { // Hater // Hatee \"Animals\" \"Citizens\" \"Animals\" \"Player\" \"Animals\" \"Police\" \"Animals\" \"Hobos\" \"Citizens\" \"Animals\" \"Police\" \"Animals\" } // Factions LIKE this Faction, they will protect them at all costs // (example of another entry for a DB thing) \"LikeFactions\" { // Liker // Liked \"Police\" \"Police\" \"Police\" \"Vendors\" \"Vendors\" \"Vendors\" \"Zealots\" \"Animals\" } } }","title":"Database"},{"location":"example/mapchecking/","text":"Map Checking \uf0c1 Do you use generalized map names like Catharsis Reborn? I.e. City01_Mon_A , City02_Mon_A , City01_Mon_B , City03_Mon_A ... Then perhaps this could help you a little bit. Execute Only If It's a City Map \uf0c1 Instead of checking a thousand map names with if elses, we can make it dynamic, so in the future it won't cause any problems.. Well that is if there's no insane person deciding to break the map naming rule. We are going to check if the map's name contains City0 , then we can assume it's an outside, city map, here's how: bool IsCityMap(string MapName) { // The function `engine.GetCurMapName()` already turns the string into lowercase.. if ( (MapName.findFirst(\"city0\")) >= 0 ) return true; return false; } Example (How to use) \uf0c1 Then in code, we can just simply call the function, but before doing so put the code in Utils.as or some global function holding file. #include \"Utils.as\" class MyClass : IPostal3Script { void MyFunction() { CP3SObj @self = GetContextOwner(); if ( @self == null ) return; if ( IsCityMap( engine.GetCurMapName() ) ) { FlyAway(); } else { PenguinWalk(); } } }","title":"Map Checking"},{"location":"example/mapchecking/#map-checking","text":"Do you use generalized map names like Catharsis Reborn? I.e. City01_Mon_A , City02_Mon_A , City01_Mon_B , City03_Mon_A ... Then perhaps this could help you a little bit.","title":"Map Checking"},{"location":"example/mapchecking/#execute-only-if-its-a-city-map","text":"Instead of checking a thousand map names with if elses, we can make it dynamic, so in the future it won't cause any problems.. Well that is if there's no insane person deciding to break the map naming rule. We are going to check if the map's name contains City0 , then we can assume it's an outside, city map, here's how: bool IsCityMap(string MapName) { // The function `engine.GetCurMapName()` already turns the string into lowercase.. if ( (MapName.findFirst(\"city0\")) >= 0 ) return true; return false; }","title":"Execute Only If It's a City Map"},{"location":"example/mapchecking/#example-how-to-use","text":"Then in code, we can just simply call the function, but before doing so put the code in Utils.as or some global function holding file. #include \"Utils.as\" class MyClass : IPostal3Script { void MyFunction() { CP3SObj @self = GetContextOwner(); if ( @self == null ) return; if ( IsCityMap( engine.GetCurMapName() ) ) { FlyAway(); } else { PenguinWalk(); } } }","title":"Example (How to use)"},{"location":"example/stimuli/","text":"Stimuli \uf0c1 When some NPCs in Catharsis Reborn/Postal 3 are fallen down, crawling, knocked out, they are generally not meant to react to some events, however to check that if they are \"stimuli-able\" you'll need a few if elses for that. So how do we just turn this into a global function, to avoid spaghetti? Check if entity can react to environment \uf0c1 In Postal 3, NPCs were only able to be \"knocked out\" but they would get up shortly after, in Catharsis Reborn it became a little bit more complicated. We added crawling (incapacitated) state, where they'll just roll on the floor until they bleed out, get knocked out, or die in pain. But the Stimuli doesn't end there, generally speaking we want to make sure NPCs are in a calm, idling state, so they are okay to stimuli , here's how: bool CanStimuli(CP3SObj@ obj) { // Player should always return true if ( obj.IsPlayer() ) return true; // Props cannot stimuli if ( obj.IsProp() || obj.IsFSM() ) return false; // Dead men can't talk if (targ.GetAttr(\"ea_health\") <= 0) return false; if (targ.IsCrawling()) return false; if (targ.IsKnockedOut()) return false; if (targ.GetCurGroup() != \"Neutral\") return false; return true; } Example (How to use) \uf0c1 Then in code, we can just simply call the function, but before doing so put the code in Utils.as or some global function holding file. #include \"Utils.as\" class MyClass : IPostal3Script { void MyFunction() { CP3SObj @self = GetContextOwner(); if ( @self == null ) return; // This array will always get the NPCs, and not props array<CP3SObj@> arr = engine.GetArrayOfNPCs(); for (uint i = 0; i < arr.length(); i++) { if ( arr[i] == null ) continue; // We shouldn't be working with ourselves here if ( arr[i] == @self ) continue; // Can't stimuli if ( !CanStimuli(arr[i]) ) continue; // They are gonna hate us now... arr[i].Relationship(self, D_HT, 1); } } }","title":"Stimuli"},{"location":"example/stimuli/#stimuli","text":"When some NPCs in Catharsis Reborn/Postal 3 are fallen down, crawling, knocked out, they are generally not meant to react to some events, however to check that if they are \"stimuli-able\" you'll need a few if elses for that. So how do we just turn this into a global function, to avoid spaghetti?","title":"Stimuli"},{"location":"example/stimuli/#check-if-entity-can-react-to-environment","text":"In Postal 3, NPCs were only able to be \"knocked out\" but they would get up shortly after, in Catharsis Reborn it became a little bit more complicated. We added crawling (incapacitated) state, where they'll just roll on the floor until they bleed out, get knocked out, or die in pain. But the Stimuli doesn't end there, generally speaking we want to make sure NPCs are in a calm, idling state, so they are okay to stimuli , here's how: bool CanStimuli(CP3SObj@ obj) { // Player should always return true if ( obj.IsPlayer() ) return true; // Props cannot stimuli if ( obj.IsProp() || obj.IsFSM() ) return false; // Dead men can't talk if (targ.GetAttr(\"ea_health\") <= 0) return false; if (targ.IsCrawling()) return false; if (targ.IsKnockedOut()) return false; if (targ.GetCurGroup() != \"Neutral\") return false; return true; }","title":"Check if entity can react to environment"},{"location":"example/stimuli/#example-how-to-use","text":"Then in code, we can just simply call the function, but before doing so put the code in Utils.as or some global function holding file. #include \"Utils.as\" class MyClass : IPostal3Script { void MyFunction() { CP3SObj @self = GetContextOwner(); if ( @self == null ) return; // This array will always get the NPCs, and not props array<CP3SObj@> arr = engine.GetArrayOfNPCs(); for (uint i = 0; i < arr.length(); i++) { if ( arr[i] == null ) continue; // We shouldn't be working with ourselves here if ( arr[i] == @self ) continue; // Can't stimuli if ( !CanStimuli(arr[i]) ) continue; // They are gonna hate us now... arr[i].Relationship(self, D_HT, 1); } } }","title":"Example (How to use)"},{"location":"globalfuncs/AddHintToList/","text":"AddHintToList \uf0c1 AddHintToList Tbd TO BE DONE","title":"void AddHintToList(CAI_Hint@ hint, bool bDebug = false)"},{"location":"globalfuncs/AddHintToList/#addhinttolist","text":"AddHintToList Tbd TO BE DONE","title":"AddHintToList"},{"location":"globalfuncs/AddToSensible/","text":"AddToSensible \uf0c1 AddToSensible Tbd TO BE DONE","title":"void AddToSensible(CBaseEntity@ ent)"},{"location":"globalfuncs/AddToSensible/#addtosensible","text":"AddToSensible Tbd TO BE DONE","title":"AddToSensible"},{"location":"globalfuncs/AngleVectors/","text":"AngleVectors \uf0c1 AngleVectors Tbd TO BE DONE","title":"void AngleVectors(QAngle ang, Vector&inout forward, Vector&inout right, Vector&inout up)"},{"location":"globalfuncs/AngleVectors/#anglevectors","text":"AngleVectors Tbd TO BE DONE","title":"AngleVectors"},{"location":"globalfuncs/Bitwise_AND/","text":"Bitwise_AND \uf0c1 Bitwise_AND Tbd TO BE DONE","title":"bool Bitwise_AND(int org, int check)"},{"location":"globalfuncs/Bitwise_AND/#bitwise_and","text":"Bitwise_AND Tbd TO BE DONE","title":"Bitwise_AND"},{"location":"globalfuncs/CanSeeSpot/","text":"CanSeeSpot \uf0c1 CanSeeSpot Tbd TO BE DONE","title":"bool CanSeeSpot(CP3SObj@ ent, Vector pos, bool bViewCone = false)"},{"location":"globalfuncs/CanSeeSpot/#canseespot","text":"CanSeeSpot Tbd TO BE DONE","title":"CanSeeSpot"},{"location":"globalfuncs/ChangeSoundVolume/","text":"ChangeSoundVolume \uf0c1 ChangeSoundVolume Tbd TO BE DONE","title":"void ChangeSoundVolume(CSoundPatch@ sound, double flVolume, double flTime)"},{"location":"globalfuncs/ChangeSoundVolume/#changesoundvolume","text":"ChangeSoundVolume Tbd TO BE DONE","title":"ChangeSoundVolume"},{"location":"globalfuncs/CreateCVar/","text":"CreateCVar \uf0c1 CreateCVar Tbd TO BE DONE","title":"ConVar@ CreateCVar(const string&in name, const string&in defValue = \"\", int flags = 0, const string&in help = \"\", bool callback = false, bool reset = false)"},{"location":"globalfuncs/CreateCVar/#createcvar","text":"CreateCVar Tbd TO BE DONE","title":"CreateCVar"},{"location":"globalfuncs/CreateContext/","text":"CreateContext \uf0c1 CreateContext Tbd TO BE DONE","title":"void CreateContext(string&in func, ?&in var = null, ?&in var2 = null, ?&in var3 = null, ?&in var4 = null, ?&in var5 = null, ?&in var6 = null, ?&in var7 = null, ?&in var8 = null, ?&in var9 = null, ?&in var10 = null, ?&in var11 = null, ?&in var12 = null, ?&in var13 = null, ?&in var14 = null, ?&in var15 = null)"},{"location":"globalfuncs/CreateContext/#createcontext","text":"CreateContext Tbd TO BE DONE","title":"CreateContext"},{"location":"globalfuncs/CreateContextClass/","text":"CreateContextClass \uf0c1 CreateContextClass Tbd TO BE DONE","title":"void CreateContextClass(string&in sclass, string&in func, ?&in var2 = null, ?&in var3 = null, ?&in var4 = null, ?&in var5 = null, ?&in var6 = null, ?&in var7 = null, ?&in var8 = null, ?&in var9 = null, ?&in var10 = null, ?&in var11 = null, ?&in var12 = null, ?&in var13 = null, ?&in var14 = null, ?&in var15 = null)"},{"location":"globalfuncs/CreateContextClass/#createcontextclass","text":"CreateContextClass Tbd TO BE DONE","title":"CreateContextClass"},{"location":"globalfuncs/CreateEffect/","text":"CreateEffect \uf0c1 CreateEffect Tbd TO BE DONE","title":"CParticleSystem@ CreateEffect(CBaseEntity@ owner, string&in effect, Vector&inout pos, QAngle&inout ang, double flTime)"},{"location":"globalfuncs/CreateEffect/#createeffect","text":"CreateEffect Tbd TO BE DONE","title":"CreateEffect"},{"location":"globalfuncs/CreateEffectAttachment/","text":"CreateEffectAttachment \uf0c1 CreateEffectAttachment Tbd TO BE DONE","title":"CParticleSystem@ CreateEffectAttachment(CBaseEntity@ owner, string&in effect, int attachment, double flTime)"},{"location":"globalfuncs/CreateEffectAttachment/#createeffectattachment","text":"CreateEffectAttachment Tbd TO BE DONE","title":"CreateEffectAttachment"},{"location":"globalfuncs/CreateEnt/","text":"CreateEnt \uf0c1 CreateEnt Tbd TO BE DONE","title":"CBaseEntity@ CreateEnt(string&in name)"},{"location":"globalfuncs/CreateEnt/#createent","text":"CreateEnt Tbd TO BE DONE","title":"CreateEnt"},{"location":"globalfuncs/CreateHint/","text":"CreateHint \uf0c1 CreateHint Tbd TO BE DONE","title":"CBaseEntity@ CreateHint()"},{"location":"globalfuncs/CreateHint/#createhint","text":"CreateHint Tbd TO BE DONE","title":"CreateHint"},{"location":"globalfuncs/CreateKeyValues/","text":"CreateKeyValues \uf0c1 CreateKeyValues Tbd TO BE DONE","title":"KeyValues@ CreateKeyValues(string&in name)"},{"location":"globalfuncs/CreateKeyValues/#createkeyvalues","text":"CreateKeyValues Tbd TO BE DONE","title":"CreateKeyValues"},{"location":"globalfuncs/CreateSound/","text":"CreateSound \uf0c1 CreateSound Tbd TO BE DONE","title":"CSoundPatch@ CreateSound(CBaseEntity@ owner, string&in name)"},{"location":"globalfuncs/CreateSound/#createsound","text":"CreateSound Tbd TO BE DONE","title":"CreateSound"},{"location":"globalfuncs/CreateTakeDamageInfo/","text":"CreateTakeDamageInfo \uf0c1 CreateTakeDamageInfo Tbd TO BE DONE","title":"CTakeDamageInfo@ CreateTakeDamageInfo()"},{"location":"globalfuncs/CreateTakeDamageInfo/#createtakedamageinfo","text":"CreateTakeDamageInfo Tbd TO BE DONE","title":"CreateTakeDamageInfo"},{"location":"globalfuncs/DebugOverlay_Box/","text":"DebugOverlay_Box \uf0c1 DebugOverlay_Box Tbd TO BE DONE","title":"void DebugOverlay_Box(const Vector&in origin, const Vector&in mins, const Vector&in maxs, int r, int g, int b, int a, double flDuration)"},{"location":"globalfuncs/DebugOverlay_Box/#debugoverlay_box","text":"DebugOverlay_Box Tbd TO BE DONE","title":"DebugOverlay_Box"},{"location":"globalfuncs/DebugOverlay_BoxAngles/","text":"DebugOverlay_BoxAngles \uf0c1 DebugOverlay_BoxAngles Tbd TO BE DONE","title":"void DebugOverlay_BoxAngles(const Vector&in origin, const Vector&in mins, const Vector&in maxs, const QAngle&in angles, int r, int g, int b, int a, double flDuration)"},{"location":"globalfuncs/DebugOverlay_BoxAngles/#debugoverlay_boxangles","text":"DebugOverlay_BoxAngles Tbd TO BE DONE","title":"DebugOverlay_BoxAngles"},{"location":"globalfuncs/DestroySound/","text":"DestroySound \uf0c1 DestroySound Tbd TO BE DONE","title":"void DestroySound(CSoundPatch@ sound)"},{"location":"globalfuncs/DestroySound/#destroysound","text":"DestroySound Tbd TO BE DONE","title":"DestroySound"},{"location":"globalfuncs/DotProduct/","text":"DotProduct \uf0c1 DotProduct Tbd TO BE DONE","title":"double DotProduct(Vector vec1, Vector vec2)"},{"location":"globalfuncs/DotProduct/#dotproduct","text":"DotProduct Tbd TO BE DONE","title":"DotProduct"},{"location":"globalfuncs/DropToFloor/","text":"DropToFloor \uf0c1 DropToFloor Tbd TO BE DONE","title":"int DropToFloor(CBaseEntity@ pEntity, uint mask, CBaseEntity@ pIgnore = null)"},{"location":"globalfuncs/DropToFloor/#droptofloor","text":"DropToFloor Tbd TO BE DONE","title":"DropToFloor"},{"location":"globalfuncs/EmitSound/","text":"EmitSound \uf0c1 EmitSound Tbd TO BE DONE","title":"EmitSound"},{"location":"globalfuncs/EmitSound/#emitsound","text":"EmitSound Tbd TO BE DONE","title":"EmitSound"},{"location":"globalfuncs/FadeInSound/","text":"FadeInSound \uf0c1 FadeInSound Tbd TO BE DONE","title":"void FadeInSound(CSoundPatch@ sound, double flTime)"},{"location":"globalfuncs/FadeInSound/#fadeinsound","text":"FadeInSound Tbd TO BE DONE","title":"FadeInSound"},{"location":"globalfuncs/FadeOutSound/","text":"FadeOutSound \uf0c1 FadeOutSound Tbd TO BE DONE","title":"void FadeOutSound(CSoundPatch@ sound, double flTime)"},{"location":"globalfuncs/FadeOutSound/#fadeoutsound","text":"FadeOutSound Tbd TO BE DONE","title":"FadeOutSound"},{"location":"globalfuncs/FadeScreen/","text":"FadeScreen \uf0c1 FadeScreen Tbd TO BE DONE","title":"void FadeScreen(int r, int g, int b, int alpha, double fadeTime, double holdTime, int flags)"},{"location":"globalfuncs/FadeScreen/#fadescreen","text":"FadeScreen Tbd TO BE DONE","title":"FadeScreen"},{"location":"globalfuncs/FindCVar/","text":"FindCVar \uf0c1 FindCVar Tbd TO BE DONE","title":"ConVar@ FindCVar(const string&in name)"},{"location":"globalfuncs/FindCVar/#findcvar","text":"FindCVar Tbd TO BE DONE","title":"FindCVar"},{"location":"globalfuncs/FindEntByName/","text":"FindEntByName \uf0c1 FindEntByName Tbd TO BE DONE","title":"CBaseEntity@ FindEntByName(string&in name)"},{"location":"globalfuncs/FindEntByName/#findentbyname","text":"FindEntByName Tbd TO BE DONE","title":"FindEntByName"},{"location":"globalfuncs/FindEntsByName/","text":"FindEntsByName \uf0c1 FindEntsByName Tbd TO BE DONE","title":"CBaseEntity@[]& FindEntsByName(string&in name)"},{"location":"globalfuncs/FindEntsByName/#findentsbyname","text":"FindEntsByName Tbd TO BE DONE","title":"FindEntsByName"},{"location":"globalfuncs/FireInput/","text":"FireInput \uf0c1 FireInput Tbd TO BE DONE","title":"FireInput"},{"location":"globalfuncs/FireInput/#fireinput","text":"FireInput Tbd TO BE DONE","title":"FireInput"},{"location":"globalfuncs/GetAmmoDef/","text":"GetAmmoDef \uf0c1 GetAmmoDef Tbd TO BE DONE","title":"CAmmoDef@ GetAmmoDef()"},{"location":"globalfuncs/GetAmmoDef/#getammodef","text":"GetAmmoDef Tbd TO BE DONE","title":"GetAmmoDef"},{"location":"globalfuncs/GetAmmoIndex/","text":"GetAmmoIndex \uf0c1 GetAmmoIndex Tbd TO BE DONE","title":"int GetAmmoIndex(string&in name)"},{"location":"globalfuncs/GetAmmoIndex/#getammoindex","text":"GetAmmoIndex Tbd TO BE DONE","title":"GetAmmoIndex"},{"location":"globalfuncs/GetAmmoMaxCarry/","text":"GetAmmoMaxCarry \uf0c1 GetAmmoMaxCarry Tbd TO BE DONE","title":"int GetAmmoMaxCarry(int ammoIndex)"},{"location":"globalfuncs/GetAmmoMaxCarry/#getammomaxcarry","text":"GetAmmoMaxCarry Tbd TO BE DONE","title":"GetAmmoMaxCarry"},{"location":"globalfuncs/GetAttachment/","text":"GetAttachment \uf0c1 GetAttachment Tbd TO BE DONE","title":"GetAttachment"},{"location":"globalfuncs/GetAttachment/#getattachment","text":"GetAttachment Tbd TO BE DONE","title":"GetAttachment"},{"location":"globalfuncs/GetCVarBool/","text":"GetCVarBool \uf0c1 GetCVarBool Tbd TO BE DONE","title":"bool GetCVarBool(const string&in cvar)"},{"location":"globalfuncs/GetCVarBool/#getcvarbool","text":"GetCVarBool Tbd TO BE DONE","title":"GetCVarBool"},{"location":"globalfuncs/GetCVarFloat/","text":"GetCVarFloat \uf0c1 GetCVarFloat Tbd TO BE DONE","title":"double GetCVarFloat(const string&in cvar)"},{"location":"globalfuncs/GetCVarFloat/#getcvarfloat","text":"GetCVarFloat Tbd TO BE DONE","title":"GetCVarFloat"},{"location":"globalfuncs/GetCVarInt/","text":"GetCVarInt \uf0c1 GetCVarInt Tbd TO BE DONE","title":"int GetCVarInt(const string&in cvar)"},{"location":"globalfuncs/GetCVarInt/#getcvarint","text":"GetCVarInt Tbd TO BE DONE","title":"GetCVarInt"},{"location":"globalfuncs/GetCVarString/","text":"GetCVarString \uf0c1 GetCVarString Tbd TO BE DONE","title":"string GetCVarString(const string&in cvar)"},{"location":"globalfuncs/GetCVarString/#getcvarstring","text":"GetCVarString Tbd TO BE DONE","title":"GetCVarString"},{"location":"globalfuncs/GetContextCaller/","text":"GetContextCaller \uf0c1 GetContextCaller Tbd TO BE DONE","title":"CP3SObj@ GetContextCaller()"},{"location":"globalfuncs/GetContextCaller/#getcontextcaller","text":"GetContextCaller Tbd TO BE DONE","title":"GetContextCaller"},{"location":"globalfuncs/GetContextOwner/","text":"GetContextOwner \uf0c1 GetContextOwner Tbd TO BE DONE","title":"CP3SObj@ GetContextOwner()"},{"location":"globalfuncs/GetContextOwner/#getcontextowner","text":"GetContextOwner Tbd TO BE DONE","title":"GetContextOwner"},{"location":"globalfuncs/GetCrosshair/","text":"GetCrosshair \uf0c1 GetCrosshair Tbd TO BE DONE","title":"CP3SObj@ GetCrosshair(CP3SObj@ pPlayer, Vector&inout endpos)"},{"location":"globalfuncs/GetCrosshair/#getcrosshair","text":"GetCrosshair Tbd TO BE DONE","title":"GetCrosshair"},{"location":"globalfuncs/GetEntById/","text":"GetEntById \uf0c1 GetEntById Tbd TO BE DONE","title":"CP3SObj@ GetEntById(int id)"},{"location":"globalfuncs/GetEntById/#getentbyid","text":"GetEntById Tbd TO BE DONE","title":"GetEntById"},{"location":"globalfuncs/GetEntId/","text":"GetEntId \uf0c1 GetEntId Tbd TO BE DONE","title":"GetEntId"},{"location":"globalfuncs/GetEntId/#getentid","text":"GetEntId Tbd TO BE DONE","title":"GetEntId"},{"location":"globalfuncs/GetGameEventBool/","text":"GetGameEventBool \uf0c1 GetGameEventBool Tbd TO BE DONE","title":"GetGameEventBool"},{"location":"globalfuncs/GetGameEventBool/#getgameeventbool","text":"GetGameEventBool Tbd TO BE DONE","title":"GetGameEventBool"},{"location":"globalfuncs/GetGameEventFloat/","text":"GetGameEventFloat \uf0c1 GetGameEventFloat Tbd TO BE DONE","title":"GetGameEventFloat"},{"location":"globalfuncs/GetGameEventFloat/#getgameeventfloat","text":"GetGameEventFloat Tbd TO BE DONE","title":"GetGameEventFloat"},{"location":"globalfuncs/GetGameEventInt/","text":"GetGameEventInt \uf0c1 GetGameEventInt Tbd TO BE DONE","title":"GetGameEventInt"},{"location":"globalfuncs/GetGameEventInt/#getgameeventint","text":"GetGameEventInt Tbd TO BE DONE","title":"GetGameEventInt"},{"location":"globalfuncs/GetGameEventName/","text":"GetGameEventName \uf0c1 GetGameEventName Tbd TO BE DONE","title":"GetGameEventName"},{"location":"globalfuncs/GetGameEventName/#getgameeventname","text":"GetGameEventName Tbd TO BE DONE","title":"GetGameEventName"},{"location":"globalfuncs/GetGameEventString/","text":"GetGameEventString \uf0c1 GetGameEventString Tbd TO BE DONE","title":"GetGameEventString"},{"location":"globalfuncs/GetGameEventString/#getgameeventstring","text":"GetGameEventString Tbd TO BE DONE","title":"GetGameEventString"},{"location":"globalfuncs/GetKeyValue/","text":"GetKeyValue \uf0c1 GetKeyValue Tbd TO BE DONE","title":"GetKeyValue"},{"location":"globalfuncs/GetKeyValue/#getkeyvalue","text":"GetKeyValue Tbd TO BE DONE","title":"GetKeyValue"},{"location":"globalfuncs/GetLocalTime/","text":"GetLocalTime \uf0c1 GetLocalTime Tbd TO BE DONE","title":"int GetLocalTime(int flag)"},{"location":"globalfuncs/GetLocalTime/#getlocaltime","text":"GetLocalTime Tbd TO BE DONE","title":"GetLocalTime"},{"location":"globalfuncs/GetName/","text":"GetName \uf0c1 GetName Tbd TO BE DONE","title":"GetName"},{"location":"globalfuncs/GetName/#getname","text":"GetName Tbd TO BE DONE","title":"GetName"},{"location":"globalfuncs/GetP3SFactionIndex/","text":"GetP3SFactionIndex \uf0c1 GetP3SFactionIndex Tbd TO BE DONE","title":"int GetP3SFactionIndex(string&in name)"},{"location":"globalfuncs/GetP3SFactionIndex/#getp3sfactionindex","text":"GetP3SFactionIndex Tbd TO BE DONE","title":"GetP3SFactionIndex"},{"location":"globalfuncs/GetP3SItemTypeIndex/","text":"GetP3SItemTypeIndex \uf0c1 GetP3SItemTypeIndex Tbd TO BE DONE","title":"int GetP3SItemTypeIndex(string&in name)"},{"location":"globalfuncs/GetP3SItemTypeIndex/#getp3sitemtypeindex","text":"GetP3SItemTypeIndex Tbd TO BE DONE","title":"GetP3SItemTypeIndex"},{"location":"globalfuncs/GetP3SMannerIndex/","text":"GetP3SMannerIndex \uf0c1 GetP3SMannerIndex Tbd TO BE DONE","title":"int GetP3SMannerIndex(string&in name)"},{"location":"globalfuncs/GetP3SMannerIndex/#getp3smannerindex","text":"GetP3SMannerIndex Tbd TO BE DONE","title":"GetP3SMannerIndex"},{"location":"globalfuncs/GetP3SVar/","text":"GetP3SVar \uf0c1 GetP3SVar Tbd TO BE DONE","title":"double GetP3SVar(string&in conststr)"},{"location":"globalfuncs/GetP3SVar/#getp3svar","text":"GetP3SVar Tbd TO BE DONE","title":"GetP3SVar"},{"location":"globalfuncs/GetPlayer/","text":"GetPlayer \uf0c1 GetPlayer Tbd TO BE DONE","title":"CP3SObj@ GetPlayer()"},{"location":"globalfuncs/GetPlayer/#getplayer","text":"GetPlayer Tbd TO BE DONE","title":"GetPlayer"},{"location":"globalfuncs/GetScriptObj/","text":"GetScriptObj \uf0c1 GetScriptObj Tbd TO BE DONE","title":"IPostal3Script@ GetScriptObj(string&in className, CP3SObj@ pOwner)"},{"location":"globalfuncs/GetScriptObj/#getscriptobj","text":"GetScriptObj Tbd TO BE DONE","title":"GetScriptObj"},{"location":"globalfuncs/GetSequenceName/","text":"GetSequenceName \uf0c1 GetSequenceName Tbd TO BE DONE","title":"GetSequenceName"},{"location":"globalfuncs/GetSequenceName/#getsequencename","text":"GetSequenceName Tbd TO BE DONE","title":"GetSequenceName"},{"location":"globalfuncs/GetTemplateData/","text":"GetTemplateData \uf0c1 GetTemplateData Tbd TO BE DONE","title":"string[]& GetTemplateData(string&in iszTemplateName)"},{"location":"globalfuncs/GetTemplateData/#gettemplatedata","text":"GetTemplateData Tbd TO BE DONE","title":"GetTemplateData"},{"location":"globalfuncs/GetTemplateDataRandom/","text":"GetTemplateDataRandom \uf0c1 GetTemplateDataRandom Tbd TO BE DONE","title":"string GetTemplateDataRandom(string&in iszTemplateName)"},{"location":"globalfuncs/GetTemplateDataRandom/#gettemplatedatarandom","text":"GetTemplateDataRandom Tbd TO BE DONE","title":"GetTemplateDataRandom"},{"location":"globalfuncs/GetVendorData/","text":"GetVendorData \uf0c1 GetVendorData Tbd TO BE DONE","title":"GetVendorData"},{"location":"globalfuncs/GetVendorData/#getvendordata","text":"GetVendorData Tbd TO BE DONE","title":"GetVendorData"},{"location":"globalfuncs/HasP3SVar/","text":"HasP3SVar \uf0c1 HasP3SVar Tbd TO BE DONE","title":"bool HasP3SVar(string&in conststr)"},{"location":"globalfuncs/HasP3SVar/#hasp3svar","text":"HasP3SVar Tbd TO BE DONE","title":"HasP3SVar"},{"location":"globalfuncs/InitString/","text":"InitString \uf0c1 InitString Tbd TO BE DONE","title":"string InitString(string&in str = \"\")"},{"location":"globalfuncs/InitString/#initstring","text":"InitString Tbd TO BE DONE","title":"InitString"},{"location":"globalfuncs/InstallCVarCallback/","text":"InstallCVarCallback \uf0c1 InstallCVarCallback Tbd TO BE DONE","title":"void InstallCVarCallback(const string&in name)"},{"location":"globalfuncs/InstallCVarCallback/#installcvarcallback","text":"InstallCVarCallback Tbd TO BE DONE","title":"InstallCVarCallback"},{"location":"globalfuncs/IsGameEventKeyEmpty/","text":"IsGameEventKeyEmpty \uf0c1 IsGameEventKeyEmpty Tbd TO BE DONE","title":"IsGameEventKeyEmpty"},{"location":"globalfuncs/IsGameEventKeyEmpty/#isgameeventkeyempty","text":"IsGameEventKeyEmpty Tbd TO BE DONE","title":"IsGameEventKeyEmpty"},{"location":"globalfuncs/IsSoundPlaying/","text":"IsSoundPlaying \uf0c1 IsSoundPlaying Tbd TO BE DONE","title":"bool IsSoundPlaying(CSoundPatch@ sound)"},{"location":"globalfuncs/IsSoundPlaying/#issoundplaying","text":"IsSoundPlaying Tbd TO BE DONE","title":"IsSoundPlaying"},{"location":"globalfuncs/ListenForGameEvent/","text":"ListenForGameEvent \uf0c1 ListenForGameEvent Tbd TO BE DONE","title":"void ListenForGameEvent(const string&in event)"},{"location":"globalfuncs/ListenForGameEvent/#listenforgameevent","text":"ListenForGameEvent Tbd TO BE DONE","title":"ListenForGameEvent"},{"location":"globalfuncs/LookupAttachment/","text":"LookupAttachment \uf0c1 LookupAttachment Tbd TO BE DONE","title":"LookupAttachment"},{"location":"globalfuncs/LookupAttachment/#lookupattachment","text":"LookupAttachment Tbd TO BE DONE","title":"LookupAttachment"},{"location":"globalfuncs/ParseEntity/","text":"ParseEntity \uf0c1 ParseEntity Tbd TO BE DONE","title":"CBaseEntity@ ParseEntity(string&in pEntData)"},{"location":"globalfuncs/ParseEntity/#parseentity","text":"ParseEntity Tbd TO BE DONE","title":"ParseEntity"},{"location":"globalfuncs/PlaySound/","text":"PlaySound \uf0c1 PlaySound Tbd TO BE DONE","title":"void PlaySound(CSoundPatch@ sound)"},{"location":"globalfuncs/PlaySound/#playsound","text":"PlaySound Tbd TO BE DONE","title":"PlaySound"},{"location":"globalfuncs/PrecacheClass/","text":"PrecacheClass \uf0c1 PrecacheClass Tbd TO BE DONE","title":"void PrecacheClass(string&in sclass)"},{"location":"globalfuncs/PrecacheClass/#precacheclass","text":"PrecacheClass Tbd TO BE DONE","title":"PrecacheClass"},{"location":"globalfuncs/PrecacheClassModel/","text":"PrecacheClassModel \uf0c1 PrecacheClassModel Tbd TO BE DONE","title":"void PrecacheClassModel(string&in sclass, string&in model)"},{"location":"globalfuncs/PrecacheClassModel/#precacheclassmodel","text":"PrecacheClassModel Tbd TO BE DONE","title":"PrecacheClassModel"},{"location":"globalfuncs/PrecacheDecal/","text":"PrecacheDecal \uf0c1 PrecacheDecal Tbd TO BE DONE","title":"void PrecacheDecal(string&in decal)"},{"location":"globalfuncs/PrecacheDecal/#precachedecal","text":"PrecacheDecal Tbd TO BE DONE","title":"PrecacheDecal"},{"location":"globalfuncs/PrecacheMaterial/","text":"PrecacheMaterial \uf0c1 PrecacheMaterial Tbd TO BE DONE","title":"void PrecacheMaterial(string&in material)"},{"location":"globalfuncs/PrecacheMaterial/#precachematerial","text":"PrecacheMaterial Tbd TO BE DONE","title":"PrecacheMaterial"},{"location":"globalfuncs/PrecacheModel/","text":"PrecacheModel \uf0c1 PrecacheModel Tbd TO BE DONE","title":"void PrecacheModel(string&in model)"},{"location":"globalfuncs/PrecacheModel/#precachemodel","text":"PrecacheModel Tbd TO BE DONE","title":"PrecacheModel"},{"location":"globalfuncs/PrecacheParticleSystem/","text":"PrecacheParticleSystem \uf0c1 PrecacheParticleSystem Tbd TO BE DONE","title":"void PrecacheParticleSystem(string&in particle)"},{"location":"globalfuncs/PrecacheParticleSystem/#precacheparticlesystem","text":"PrecacheParticleSystem Tbd TO BE DONE","title":"PrecacheParticleSystem"},{"location":"globalfuncs/PrecacheScriptSound/","text":"PrecacheScriptSound \uf0c1 PrecacheScriptSound Tbd TO BE DONE","title":"void PrecacheScriptSound(string&in scriptsound)"},{"location":"globalfuncs/PrecacheScriptSound/#precachescriptsound","text":"PrecacheScriptSound Tbd TO BE DONE","title":"PrecacheScriptSound"},{"location":"globalfuncs/PrecacheSound/","text":"PrecacheSound \uf0c1 PrecacheSound Tbd TO BE DONE","title":"void PrecacheSound(string&in sound)"},{"location":"globalfuncs/PrecacheSound/#precachesound","text":"PrecacheSound Tbd TO BE DONE","title":"PrecacheSound"},{"location":"globalfuncs/Printf/","text":"Printf \uf0c1 Printf Tbd TO BE DONE","title":"void Printf(string&in msg, ?&in var = 0, ?&in var2 = 0, ?&in var3 = 0, ?&in var4 = 0, ?&in var5 = 0, ?&in var6 = 0, ?&in var7 = 0, ?&in var8 = 0, ?&in var9 = 0, ?&in var10 = 0, ?&in var11 = 0, ?&in var12 = 0, ?&in var13 = 0, ?&in var14 = 0, ?&in var15 = 0)"},{"location":"globalfuncs/Printf/#printf","text":"Printf Tbd TO BE DONE","title":"Printf"},{"location":"globalfuncs/RandomFloat/","text":"RandomFloat \uf0c1 RandomFloat Tbd TO BE DONE","title":"double RandomFloat(double min, double max)"},{"location":"globalfuncs/RandomFloat/#randomfloat","text":"RandomFloat Tbd TO BE DONE","title":"RandomFloat"},{"location":"globalfuncs/RandomInt/","text":"RandomInt \uf0c1 RandomInt Tbd TO BE DONE","title":"int RandomInt(int min, int max)"},{"location":"globalfuncs/RandomInt/#randomint","text":"RandomInt Tbd TO BE DONE","title":"RandomInt"},{"location":"globalfuncs/Remove/","text":"Remove \uf0c1 Remove Tbd TO BE DONE","title":"void Remove(CBaseEntity@ ent)"},{"location":"globalfuncs/Remove/#remove","text":"Remove Tbd TO BE DONE","title":"Remove"},{"location":"globalfuncs/RemoveEnt/","text":"RemoveEnt \uf0c1 RemoveEnt Tbd TO BE DONE","title":"void RemoveEnt(CBaseEntity@ ent)"},{"location":"globalfuncs/RemoveEnt/#removeent","text":"RemoveEnt Tbd TO BE DONE","title":"RemoveEnt"},{"location":"globalfuncs/SetAbsAngles/","text":"SetAbsAngles \uf0c1 SetAbsAngles Tbd TO BE DONE","title":"SetAbsAngles"},{"location":"globalfuncs/SetAbsAngles/#setabsangles","text":"SetAbsAngles Tbd TO BE DONE","title":"SetAbsAngles"},{"location":"globalfuncs/SetAbsOrigin/","text":"SetAbsOrigin \uf0c1 SetAbsOrigin Tbd TO BE DONE","title":"SetAbsOrigin"},{"location":"globalfuncs/SetAbsOrigin/#setabsorigin","text":"SetAbsOrigin Tbd TO BE DONE","title":"SetAbsOrigin"},{"location":"globalfuncs/SetKeyValue/","text":"SetKeyValue \uf0c1 SetKeyValue Tbd TO BE DONE","title":"SetKeyValue"},{"location":"globalfuncs/SetKeyValue/#setkeyvalue","text":"SetKeyValue Tbd TO BE DONE","title":"SetKeyValue"},{"location":"globalfuncs/SetName/","text":"SetName \uf0c1 SetName Tbd TO BE DONE","title":"SetName"},{"location":"globalfuncs/SetName/#setname","text":"SetName Tbd TO BE DONE","title":"SetName"},{"location":"globalfuncs/SetSoundVolume/","text":"SetSoundVolume \uf0c1 SetSoundVolume Tbd TO BE DONE","title":"void SetSoundVolume(CSoundPatch@ sound, double flVolume)"},{"location":"globalfuncs/SetSoundVolume/#setsoundvolume","text":"SetSoundVolume Tbd TO BE DONE","title":"SetSoundVolume"},{"location":"globalfuncs/SetState/","text":"SetState \uf0c1 SetState Tbd TO BE DONE","title":"int SetState(CP3SObj@ ent, string&in state, string&in pattern)"},{"location":"globalfuncs/SetState/#setstate","text":"SetState Tbd TO BE DONE","title":"SetState"},{"location":"globalfuncs/ShowMessage/","text":"ShowMessage \uf0c1 ShowMessage Tbd TO BE DONE","title":"void ShowMessage(string&in msg, string&in channel)"},{"location":"globalfuncs/ShowMessage/#showmessage","text":"ShowMessage Tbd TO BE DONE","title":"ShowMessage"},{"location":"globalfuncs/Spawn/","text":"Spawn \uf0c1 Spawn Tbd TO BE DONE","title":"void Spawn(CBaseEntity@ ent)"},{"location":"globalfuncs/Spawn/#spawn","text":"Spawn Tbd TO BE DONE","title":"Spawn"},{"location":"globalfuncs/StopListeningForGameEvents/","text":"StopListeningForGameEvents \uf0c1 StopListeningForGameEvents Tbd TO BE DONE","title":"void StopListeningForGameEvents()"},{"location":"globalfuncs/StopListeningForGameEvents/#stoplisteningforgameevents","text":"StopListeningForGameEvents Tbd TO BE DONE","title":"StopListeningForGameEvents"},{"location":"globalfuncs/StopSound/","text":"StopSound \uf0c1 StopSound Tbd TO BE DONE","title":"void StopSound(CSoundPatch@ sound)"},{"location":"globalfuncs/StopSound/#stopsound","text":"StopSound Tbd TO BE DONE","title":"StopSound"},{"location":"globalfuncs/StringToInt/","text":"StringToInt \uf0c1 StringToInt Tbd TO BE DONE","title":"int StringToInt(string&in str)"},{"location":"globalfuncs/StringToInt/#stringtoint","text":"StringToInt Tbd TO BE DONE","title":"StringToInt"},{"location":"globalfuncs/StringToVector/","text":"StringToVector \uf0c1 StringToVector Tbd TO BE DONE","title":"void StringToVector(Vector&inout vec, string&in str)"},{"location":"globalfuncs/StringToVector/#stringtovector","text":"StringToVector Tbd TO BE DONE","title":"StringToVector"},{"location":"globalfuncs/Teleport/","text":"Teleport \uf0c1 Teleport Tbd TO BE DONE","title":"void Teleport(CBaseEntity@ ent, Vector pos)"},{"location":"globalfuncs/Teleport/#teleport","text":"Teleport Tbd TO BE DONE","title":"Teleport"},{"location":"globalfuncs/ToCBaseEntity/","text":"ToCBaseEntity \uf0c1 ToCBaseEntity Tbd TO BE DONE","title":"CBaseEntity@ ToCBaseEntity(?&in var)"},{"location":"globalfuncs/ToCBaseEntity/#tocbaseentity","text":"ToCBaseEntity Tbd TO BE DONE","title":"ToCBaseEntity"},{"location":"globalfuncs/ToCRProp/","text":"ToCRProp \uf0c1 ToCRProp Tbd TO BE DONE","title":"ToCRProp"},{"location":"globalfuncs/ToCRProp/#tocrprop","text":"ToCRProp Tbd TO BE DONE","title":"ToCRProp"},{"location":"globalfuncs/ToHelicopter/","text":"ToHelicopter \uf0c1 ToHelicopter Tbd TO BE DONE","title":"ToHelicopter"},{"location":"globalfuncs/ToHelicopter/#tohelicopter","text":"ToHelicopter Tbd TO BE DONE","title":"ToHelicopter"},{"location":"globalfuncs/ToggleFSMOverlay/","text":"ToggleFSMOverlay \uf0c1 ToggleFSMOverlay Tbd TO BE DONE","title":"void ToggleFSMOverlay(CBaseEntity@ ent)"},{"location":"globalfuncs/ToggleFSMOverlay/#togglefsmoverlay","text":"ToggleFSMOverlay Tbd TO BE DONE","title":"ToggleFSMOverlay"},{"location":"globalfuncs/UnicodeToANSI/","text":"UnicodeToANSI \uf0c1 UnicodeToANSI Tbd TO BE DONE","title":"string UnicodeToANSI(string&in unicode, bool bCleanup = true)"},{"location":"globalfuncs/UnicodeToANSI/#unicodetoansi","text":"UnicodeToANSI Tbd TO BE DONE","title":"UnicodeToANSI"},{"location":"globalfuncs/ValidateHints/","text":"ValidateHints \uf0c1 ValidateHints Tbd TO BE DONE","title":"void ValidateHints()"},{"location":"globalfuncs/ValidateHints/#validatehints","text":"ValidateHints Tbd TO BE DONE","title":"ValidateHints"},{"location":"globalfuncs/VectorNormalize/","text":"VectorNormalize \uf0c1 VectorNormalize Tbd TO BE DONE","title":"double VectorNormalize(Vector&inout vec)"},{"location":"globalfuncs/VectorNormalize/#vectornormalize","text":"VectorNormalize Tbd TO BE DONE","title":"VectorNormalize"},{"location":"globalfuncs/Wait/","text":"Wait \uf0c1 Wait Tbd TO BE DONE","title":"void Wait(double flTime, int iHandle = 0)"},{"location":"globalfuncs/Wait/#wait","text":"Wait Tbd TO BE DONE","title":"Wait"},{"location":"globalfuncs/Warning/","text":"Warning \uf0c1 Warning Tbd TO BE DONE","title":"void Warning(string&in msg, ?&in var = 0, ?&in var2 = 0, ?&in var3 = 0, ?&in var4 = 0, ?&in var5 = 0, ?&in var6 = 0, ?&in var7 = 0, ?&in var8 = 0, ?&in var9 = 0, ?&in var10 = 0, ?&in var11 = 0, ?&in var12 = 0, ?&in var13 = 0, ?&in var14 = 0, ?&in var15 = 0)"},{"location":"globalfuncs/Warning/#warning","text":"Warning Tbd TO BE DONE","title":"Warning"},{"location":"globalfuncs/formatFloat/","text":"formatFloat \uf0c1 formatFloat Tbd TO BE DONE","title":"string formatFloat(double val, const string&in options = \"\", uint width = 0, uint precision = 0)"},{"location":"globalfuncs/formatFloat/#formatfloat","text":"formatFloat Tbd TO BE DONE","title":"formatFloat"},{"location":"globalfuncs/formatInt/","text":"formatInt \uf0c1 formatInt Tbd TO BE DONE","title":"string formatInt(int64 val, const string&in options = \"\", uint width = 0)"},{"location":"globalfuncs/formatInt/#formatint","text":"formatInt Tbd TO BE DONE","title":"formatInt"},{"location":"globalfuncs/formatUInt/","text":"formatUInt \uf0c1 formatUInt Tbd TO BE DONE","title":"string formatUInt(uint64 val, const string&in options = \"\", uint width = 0)"},{"location":"globalfuncs/formatUInt/#formatuint","text":"formatUInt Tbd TO BE DONE","title":"formatUInt"},{"location":"globalfuncs/parseFloat/","text":"parseFloat \uf0c1 parseFloat Tbd TO BE DONE","title":"double parseFloat(const string&in, uint&out byteCount = 0)"},{"location":"globalfuncs/parseFloat/#parsefloat","text":"parseFloat Tbd TO BE DONE","title":"parseFloat"},{"location":"globalfuncs/parseInt/","text":"parseInt \uf0c1 parseInt Tbd TO BE DONE","title":"int64 parseInt(const string&in, uint base = 10, uint&out byteCount = 0)"},{"location":"globalfuncs/parseInt/#parseint","text":"parseInt Tbd TO BE DONE","title":"parseInt"},{"location":"globalfuncs/parseUInt/","text":"parseUInt \uf0c1 parseUInt Tbd TO BE DONE","title":"uint64 parseUInt(const string&in, uint base = 10, uint&out byteCount = 0)"},{"location":"globalfuncs/parseUInt/#parseuint","text":"parseUInt Tbd TO BE DONE","title":"parseUInt"},{"location":"globalvars/engine/","text":"engine \uf0c1 Note The methods here might be converted into global functions in the future. Methods \uf0c1 float GetCurTime() -- Gets the current time. string GetCurMapName() -- Gets the current map name. int GetCurLoadType() -- Gets the current load type. void ClientCommand(string &in) -- Executes client commands in place of the player. float CalcDistance(CP3SObj@, CP3SObj@) -- Calculates distance between 2 objects. float CalcDistanceZ(CP3SObj@, CP3SObj@) -- Calculates Z distance between 2 objects. array<CP3SObj@>& GetArrayOfNPCs() -- Gets all the NPCs on the level, and puts them into an array. array<CP3SObj@>& GetArrayOfPlayers() -- Gets all the connected and spawned Players. array<CP3SObj@>& GetArrayOfEntitiesRadius(CP3SObj@, float) -- Gets all the NPCs in a specified radius around an object. CR array<CP3SObj@>& GetArrayOfSavedFSMEntities(CP3SObj@) -- Gets all the saved FSM entities of an object. CR array<CP3SObj@>& GetArrayOfInventory(CP3SObj@) -- Gets the array of an object's inventory. array<CP3SObj@>& GetArrayOfWeapons(CP3SObj@ owner) -- Gets the array of an object's weapons. If the game is not CR then it only gets the Player's weapons. array<CP3SObj@>& GetArrayOfP3SObjs() -- Gets all the P3S Objects in the map. void DelayedExecution(float, string &in, string &in, CP3SObj@) -- Executes a function with delay. bool IsMultiplayer() -- Returns true if game is Multiplayer. void AddGlobalBool(bool bSet, int iNum) -- Adds a global boolean which never resets. int GetGlobalBool(int iNum) -- Gets the global boolean. Returns -1 if it doesn't exist. void AddStaticBool(bool bSet, int iNum) -- Adds a static boolean which will reset after a new game. int GetStaticBool(int iNum) -- Gets the static boolean. Returns -1 if it doesn't exist.","title":"CAngelScriptVM engine"},{"location":"globalvars/engine/#engine","text":"Note The methods here might be converted into global functions in the future.","title":"engine"},{"location":"globalvars/engine/#methods","text":"float GetCurTime() -- Gets the current time. string GetCurMapName() -- Gets the current map name. int GetCurLoadType() -- Gets the current load type. void ClientCommand(string &in) -- Executes client commands in place of the player. float CalcDistance(CP3SObj@, CP3SObj@) -- Calculates distance between 2 objects. float CalcDistanceZ(CP3SObj@, CP3SObj@) -- Calculates Z distance between 2 objects. array<CP3SObj@>& GetArrayOfNPCs() -- Gets all the NPCs on the level, and puts them into an array. array<CP3SObj@>& GetArrayOfPlayers() -- Gets all the connected and spawned Players. array<CP3SObj@>& GetArrayOfEntitiesRadius(CP3SObj@, float) -- Gets all the NPCs in a specified radius around an object. CR array<CP3SObj@>& GetArrayOfSavedFSMEntities(CP3SObj@) -- Gets all the saved FSM entities of an object. CR array<CP3SObj@>& GetArrayOfInventory(CP3SObj@) -- Gets the array of an object's inventory. array<CP3SObj@>& GetArrayOfWeapons(CP3SObj@ owner) -- Gets the array of an object's weapons. If the game is not CR then it only gets the Player's weapons. array<CP3SObj@>& GetArrayOfP3SObjs() -- Gets all the P3S Objects in the map. void DelayedExecution(float, string &in, string &in, CP3SObj@) -- Executes a function with delay. bool IsMultiplayer() -- Returns true if game is Multiplayer. void AddGlobalBool(bool bSet, int iNum) -- Adds a global boolean which never resets. int GetGlobalBool(int iNum) -- Gets the global boolean. Returns -1 if it doesn't exist. void AddStaticBool(bool bSet, int iNum) -- Adds a static boolean which will reset after a new game. int GetStaticBool(int iNum) -- Gets the static boolean. Returns -1 if it doesn't exist.","title":"Methods"},{"location":"globalvars/gameeventmanager/","text":"IGameEventManager gameeventmanager \uf0c1 Game event manager. Methods \uf0c1 IGameEvent@ CreateEvent(string name, bool bForce = false) bool FireEvent(IGameEvent@ event, bool bDontBroadcast = false) bool FireEventClientSide(IGameEvent@ event)","title":"IGameEventManager gameeventmanager"},{"location":"globalvars/gameeventmanager/#igameeventmanager-gameeventmanager","text":"Game event manager.","title":"IGameEventManager gameeventmanager"},{"location":"globalvars/gameeventmanager/#methods","text":"IGameEvent@ CreateEvent(string name, bool bForce = false) bool FireEvent(IGameEvent@ event, bool bDontBroadcast = false) bool FireEventClientSide(IGameEvent@ event)","title":"Methods"},{"location":"globalvars/gpglobals/","text":"CGlobalVars gpGlobals \uf0c1 Methods: \uf0c1 int eLoadType() string mapname() string startspot() Properties: \uf0c1 double curtime double absoluteframetime bool bMapLoadFailed bool coop bool deathmatch int framecount double frametime double interval_per_tick int mapversion int maxClients int network_protocol int serverCount double realtime int simTicksThisFrame bool teamplay int tickcount","title":"CGlobalVars gpGlobals"},{"location":"globalvars/gpglobals/#cglobalvars-gpglobals","text":"","title":"CGlobalVars gpGlobals"},{"location":"globalvars/gpglobals/#methods","text":"int eLoadType() string mapname() string startspot()","title":"Methods:"},{"location":"globalvars/gpglobals/#properties","text":"double curtime double absoluteframetime bool bMapLoadFailed bool coop bool deathmatch int framecount double frametime double interval_per_tick int mapversion int maxClients int network_protocol int serverCount double realtime int simTicksThisFrame bool teamplay int tickcount","title":"Properties:"},{"location":"interfaces/ipostal3script/","text":"IPostal3Script \uf0c1 The interface which all classes use. Note It doesn't serve any purpose other than to save performance.","title":"IPostal3Script"},{"location":"interfaces/ipostal3script/#ipostal3script","text":"The interface which all classes use. Note It doesn't serve any purpose other than to save performance.","title":"IPostal3Script"},{"location":"objects/ammo_t/","text":"Ammo_t@ \uf0c1 Ammo. Methods \uf0c1 string pAmmoSound() string pName() Variables \uf0c1 Note Variables should be read-only, do not write to it as it can cause side-effects! int eTracerType int nDamageType int nFlags int nMaxSplashSize int nMinSplashSize float physicsForceImpulse int pMaxCarry int pNPCDmg int pPlrDmg","title":"Ammo_t@"},{"location":"objects/ammo_t/#ammo_t","text":"Ammo.","title":"Ammo_t@"},{"location":"objects/ammo_t/#methods","text":"string pAmmoSound() string pName()","title":"Methods"},{"location":"objects/ammo_t/#variables","text":"Note Variables should be read-only, do not write to it as it can cause side-effects! int eTracerType int nDamageType int nFlags int nMaxSplashSize int nMinSplashSize float physicsForceImpulse int pMaxCarry int pNPCDmg int pPlrDmg","title":"Variables"},{"location":"objects/cammodef/","text":"CAmmoDef@ \uf0c1 Ammo definition. Methods \uf0c1 void AddAmmoType(string name, int damageType, int tracerType, string plrcvar, string npccvar, string carryvar, string ammoSound, float physicsForceImpulse, int nFlags, int minSplashSize = 4, int maxSplashSize = 8) -- NOTE: Not tested! float DamageForce(int nAmmoIndex) int DamageType(int nAmmoIndex) int Flags(int nAmmoIndex) Ammo_t@ GetAmmoOfIndex(int nAmmoIndex) int Index(string psz) int MaxCarry(int nAmmoIndex) int MaxSplashSize(int nAmmoIndex) int MinSplashSize(int nAmmoIndex) int NPCDamage(int nAmmoIndex) int PlrDamage(int nAmmoIndex)","title":"CAmmoDef@"},{"location":"objects/cammodef/#cammodef","text":"Ammo definition.","title":"CAmmoDef@"},{"location":"objects/cammodef/#methods","text":"void AddAmmoType(string name, int damageType, int tracerType, string plrcvar, string npccvar, string carryvar, string ammoSound, float physicsForceImpulse, int nFlags, int minSplashSize = 4, int maxSplashSize = 8) -- NOTE: Not tested! float DamageForce(int nAmmoIndex) int DamageType(int nAmmoIndex) int Flags(int nAmmoIndex) Ammo_t@ GetAmmoOfIndex(int nAmmoIndex) int Index(string psz) int MaxCarry(int nAmmoIndex) int MaxSplashSize(int nAmmoIndex) int MinSplashSize(int nAmmoIndex) int NPCDamage(int nAmmoIndex) int PlrDamage(int nAmmoIndex)","title":"Methods"},{"location":"objects/cbaseentity/","text":"CBaseEntity@ \uf0c1 The base entity of all entities in Source Engine games. Methods: \uf0c1 CP3SObj@ GetP3SObj() -- Gets the P3S object of the entity. Vector& GetAbsOrigin() -- Gets the absolute origin of the entity. Vector& WorldSpaceCenter() -- Gets the world space center of the entity. QAngle& GetAbsAngles() -- Gets the absolute angle of the entity. QAngle EyeAngles() -- Gets the eye angles of the entity. Vector& GetLocalOrigin() -- Gets the local origin of the entity. QAngle& GetLocalAngles() -- Gets the local angles of the entity. void SetAbsOrigin(Vector pos) -- Sets the absolute origin of the entity. void SetAbsAngles(QAngle ang) -- Sets the absolute angles of the entity. void SetLocalOrigin(Vector pos) -- Sets the local origin of the entity. void SetLocalAngles(QAngle ang) -- Sets the local angles of the entity. void KeyValue(string&in key, string&in value) -- Sets a keyvalue of the entity before it spawns. string GetKeyValue(string&in key) -- Gets a keyvalue. void SetName(string&in newName) -- Sets a new (target)name for the entity. void FireInput(string&in input, string&in value = \"\") -- Fires an input. string GetName() -- Gets the (target)name. int GetEntIndex() -- Gets the entity index. string GetClassName() -- Gets the class name. (i.e. p3_npc_citizen) void AddEffects(int effect) -- Adds effects. void RemoveEffects(int effect) -- Removes effects. void ClearEffects() -- Clears all the effects. void AddSpawnFlags(int nFlags) -- Adds spawn flags. void RemoveSpawnFlags(int nFlags) -- Removes spawn flags. string GetSequenceName(int iSequence) -- Gets a sequence's name from a sequence's index. int GetSequence() void SetSequence(int nSequence) void ResetSequence(int nSequence) int LookupSequence(string&in seq) void GetAttachment(int attach, Vector&inout pos, QAngle&inout ang) -- Gets an attachment's position and angle. int LookupAttachment(string&in str) -- Gets the index of an attachment. void Activate() -- Activates the entity. Used after spawned. CBaseEntity@ GetParent() -- Gets the parent entity. bool IsInWorld() -- Checks if the entity is not out of bounds. void SetCollisionGroup(int group) -- Sets the collision group. int GetFlags() -- Gets the flags. (FL_) int GetSolidFlags() -- Gets the solid flags. (FSOLID_) void SetNextThink(double nextThinkTime) -- Sets the next think time. void SetThink(int subFlag) -- Sets the think function. (SUB_) void SetParent(CBaseEntity@ pNewParent, int iAttachment = - 1) -- Sets a new parent. void SetOwnerEntity(CBaseEntity@ pNewOwner) -- Sets an owner entity for the entity. void Headblob(string&in hbName) -- Sets a headblob. string GetModelName() -- Gets the model name in full path. void SetPrefab(int iPrefab) -- Sets a new prefab. void SetModel(string&in newModel) -- Sets a new model. int LookupPrefab(string&in szName) -- Looks up a prefab's index. int GetActivity() -- Gets current activity index. int GetIdealActivity() -- Gets current ideal activity index. void RemoveAllGestures() -- Removes all gestures. void SetActivity(int iNewActivity) -- Sets a new activity. void SetIdealActivity(int iNewIdealActivity) -- Sets a new ideal activity. void RemoveAllBoltons() -- Removes all boltons. void AddBolton(int iBolton) -- Adds a new bolton. int GetBodygroup(int iGroup) -- Gets the index of a bodygroup. string GetBodygroupName(int iGroup) -- Gets the name of a bodygroup. void SetBodygroup(int iGroup, int iValue) -- Sets a bodygroup's value. int FindBodygroupByName(string&in szName) -- Finds a bodygroup's index by name. void SetSkin(int iSkin) -- Sets a new skin. int GetSkins() -- Gets all available skins. int GetSkin() -- Gets current skin. bool HasNetworkProp() -- Checks if entity has a network prop. CParticleSystem@ GetParticlePointer() -- Gets the particle pointer, if there's any. (OBSOLETE) bool IsDeleted() -- Checks if entity is marked for deletion. (therefore not safe to use) CPhysObj@ VPhysicsInitNormal(int solidType, int nSolidFlags, bool createAsleep) -- Inits vphysics. CPhysObj@ VPhysicsGetObject() -- Gets the Physics pointer.","title":"CBaseEntity@"},{"location":"objects/cbaseentity/#cbaseentity","text":"The base entity of all entities in Source Engine games.","title":"CBaseEntity@"},{"location":"objects/cbaseentity/#methods","text":"CP3SObj@ GetP3SObj() -- Gets the P3S object of the entity. Vector& GetAbsOrigin() -- Gets the absolute origin of the entity. Vector& WorldSpaceCenter() -- Gets the world space center of the entity. QAngle& GetAbsAngles() -- Gets the absolute angle of the entity. QAngle EyeAngles() -- Gets the eye angles of the entity. Vector& GetLocalOrigin() -- Gets the local origin of the entity. QAngle& GetLocalAngles() -- Gets the local angles of the entity. void SetAbsOrigin(Vector pos) -- Sets the absolute origin of the entity. void SetAbsAngles(QAngle ang) -- Sets the absolute angles of the entity. void SetLocalOrigin(Vector pos) -- Sets the local origin of the entity. void SetLocalAngles(QAngle ang) -- Sets the local angles of the entity. void KeyValue(string&in key, string&in value) -- Sets a keyvalue of the entity before it spawns. string GetKeyValue(string&in key) -- Gets a keyvalue. void SetName(string&in newName) -- Sets a new (target)name for the entity. void FireInput(string&in input, string&in value = \"\") -- Fires an input. string GetName() -- Gets the (target)name. int GetEntIndex() -- Gets the entity index. string GetClassName() -- Gets the class name. (i.e. p3_npc_citizen) void AddEffects(int effect) -- Adds effects. void RemoveEffects(int effect) -- Removes effects. void ClearEffects() -- Clears all the effects. void AddSpawnFlags(int nFlags) -- Adds spawn flags. void RemoveSpawnFlags(int nFlags) -- Removes spawn flags. string GetSequenceName(int iSequence) -- Gets a sequence's name from a sequence's index. int GetSequence() void SetSequence(int nSequence) void ResetSequence(int nSequence) int LookupSequence(string&in seq) void GetAttachment(int attach, Vector&inout pos, QAngle&inout ang) -- Gets an attachment's position and angle. int LookupAttachment(string&in str) -- Gets the index of an attachment. void Activate() -- Activates the entity. Used after spawned. CBaseEntity@ GetParent() -- Gets the parent entity. bool IsInWorld() -- Checks if the entity is not out of bounds. void SetCollisionGroup(int group) -- Sets the collision group. int GetFlags() -- Gets the flags. (FL_) int GetSolidFlags() -- Gets the solid flags. (FSOLID_) void SetNextThink(double nextThinkTime) -- Sets the next think time. void SetThink(int subFlag) -- Sets the think function. (SUB_) void SetParent(CBaseEntity@ pNewParent, int iAttachment = - 1) -- Sets a new parent. void SetOwnerEntity(CBaseEntity@ pNewOwner) -- Sets an owner entity for the entity. void Headblob(string&in hbName) -- Sets a headblob. string GetModelName() -- Gets the model name in full path. void SetPrefab(int iPrefab) -- Sets a new prefab. void SetModel(string&in newModel) -- Sets a new model. int LookupPrefab(string&in szName) -- Looks up a prefab's index. int GetActivity() -- Gets current activity index. int GetIdealActivity() -- Gets current ideal activity index. void RemoveAllGestures() -- Removes all gestures. void SetActivity(int iNewActivity) -- Sets a new activity. void SetIdealActivity(int iNewIdealActivity) -- Sets a new ideal activity. void RemoveAllBoltons() -- Removes all boltons. void AddBolton(int iBolton) -- Adds a new bolton. int GetBodygroup(int iGroup) -- Gets the index of a bodygroup. string GetBodygroupName(int iGroup) -- Gets the name of a bodygroup. void SetBodygroup(int iGroup, int iValue) -- Sets a bodygroup's value. int FindBodygroupByName(string&in szName) -- Finds a bodygroup's index by name. void SetSkin(int iSkin) -- Sets a new skin. int GetSkins() -- Gets all available skins. int GetSkin() -- Gets current skin. bool HasNetworkProp() -- Checks if entity has a network prop. CParticleSystem@ GetParticlePointer() -- Gets the particle pointer, if there's any. (OBSOLETE) bool IsDeleted() -- Checks if entity is marked for deletion. (therefore not safe to use) CPhysObj@ VPhysicsInitNormal(int solidType, int nSolidFlags, bool createAsleep) -- Inits vphysics. CPhysObj@ VPhysicsGetObject() -- Gets the Physics pointer.","title":"Methods:"},{"location":"objects/cgameevent/","text":"CGameEvent@ \uf0c1 Game event. Methods \uf0c1 bool IsReliable() bool IsLocal() bool IsEmpty() bool GetBool(string keyName, bool defaultValue = false) int GetInt(string keyName, int defaultValue = 0) double GetFloat(string keyName, double defaultValue = 0.0f) string GetString(string keyName, string defaultValue = \"\") void SetBool(string keyName, bool value) void SetInt(string keyName, int value) void SetFloat(string keyName, double value) void SetString(string keyName, string value)","title":"CGameEvent@"},{"location":"objects/cgameevent/#cgameevent","text":"Game event.","title":"CGameEvent@"},{"location":"objects/cgameevent/#methods","text":"bool IsReliable() bool IsLocal() bool IsEmpty() bool GetBool(string keyName, bool defaultValue = false) int GetInt(string keyName, int defaultValue = 0) double GetFloat(string keyName, double defaultValue = 0.0f) string GetString(string keyName, string defaultValue = \"\") void SetBool(string keyName, bool value) void SetInt(string keyName, int value) void SetFloat(string keyName, double value) void SetString(string keyName, string value)","title":"Methods"},{"location":"objects/convar/","text":"ConVar@ \uf0c1 Console command. Methods \uf0c1 void AddFlags(int flags) string GetDefault() bool GetBool() double GetFloat() string GetHelpText() int GetInt() bool GetMax(double&inout maxVal) bool GetMin(double&inout minVal) string GetString() string GetName() void Revert() void SetDefault(string value) void SetValue(string value) void InstallCallback() - Calls SEngine::OnCVarChanged(string name, string OldString, float OldValue) globally whenever the console command's value was changed.","title":"ConVar@"},{"location":"objects/convar/#convar","text":"Console command.","title":"ConVar@"},{"location":"objects/convar/#methods","text":"void AddFlags(int flags) string GetDefault() bool GetBool() double GetFloat() string GetHelpText() int GetInt() bool GetMax(double&inout maxVal) bool GetMin(double&inout minVal) string GetString() string GetName() void Revert() void SetDefault(string value) void SetValue(string value) void InstallCallback() - Calls SEngine::OnCVarChanged(string name, string OldString, float OldValue) globally whenever the console command's value was changed.","title":"Methods"},{"location":"objects/cp3sobj/","text":"CP3SObj@ \uf0c1 The scripting entity which is attached to all POSTAL3 entities, this is what Postal3Script is using for it's scripting. Methods \uf0c1 Attributes \uf0c1 int GetAttr(const string&in sAttr) -- Gets the value of an entity. bool HasAttr(const string&in sAttr) -- Checks if an attribute exists. bool SetAttr(const string&in sAttr, int val, int min = -1, int max = 100) -- Sets or creates an attribute with values specified. bool RemoveAttr(const string&in sAttr) -- Removes an attribute if it exists. Pointers \uf0c1 CBaseEntity@ GetBaseEntity() -- Gets the base entity pointer. CP3SObj@ GetTarget() -- Gets the current P3S target. CP3SObj@ GetCaller() -- Gets the current P3S caller. CP3SObj@ GetMemory(int iSlot) -- Gets the object from a memory slot, if it exists. Min: 0 Max: 15 CP3SObj@ GetWeapon() -- Gets the held weapon, if there's any. CP3SObj@ GetAnchor() -- Gets the anchor, if there's any. CP3SObj@ GetItem() -- Gets currently held item, if there's any. CP3Weapon@ GetWeaponPtr() -- Gets the weapon pointer for the object's weapon. For Player it is always the active weapon, for NPCs it is always the Melee or Ranged weapon stored. Targeting \uf0c1 void SetTarget(CP3SObj@ ent) -- Sets P3S target. void SetEnemy(CP3SObj@ pEnemy, bool bSetCondNewEnemy = true) -- Sets the enemy. void SetCaller(CP3SObj@ ent) -- Sets P3S caller. void SetMemory(CP3SObj@ ent, int iSlot) -- Saves an object to the memory slot. Min: 0 Max: 15 void Ignore(CP3SObj@ ent, float flTime) -- Ignores an object for a specified amount of time. bool IsIgnored(CP3SObj@ ent) -- Checks if object is already ignored. States, Patterns \uf0c1 bool State(string&in sState) -- Sets the P3S state. bool Pattern(string&in sPattern) -- Sets the P3S pattern, from it's current P3S state. void ExecutePattern(string&in sXptPattern) -- Executes a P3S pattern externally. void FireEvent(string&in sEvent, CP3SObj@ obj = null) -- Fires a P3S event, caller(obj) is optional. bool HasAI() -- Checks if entity has a behavior defined. Timers \uf0c1 bool GetTimer(string&in timerName) -- Checks if Timer exists. void SetTimer(string&in timerName, float flTime, bool bRepeated) -- Sets a Timer, seconds, and should it repeat. float GetTimerVal(string&in timerName) -- Gets a Timer's current interval (seconds). 0 or below means the Timer has elapsed. float GetTimerFreq(string&in timerName) -- Gets the Timer's frequency. bool IsTimerRepeated(string&in timerName) -- Checks if Timer is repeated. Data \uf0c1 void SetBehavior(string&in Behavior, string& Manner = null, string& Faction = null, string& Init = null, string& Start = null) -- Sets the new behavior for the object. string GetManner() -- Gets the manner's name. string GetFaction() -- Gets the faction's name. string GetCurState() -- Gets the current P3S state's name. string GetCurGroup() -- Gets the current P3S state's group's name. (Neutral, Alert, Combat) string GetBehavior() -- Gets the behavior name. string GetInherit() -- Gets the inherited behavior name, if there's any. string GetCurPattern() -- Gets the current P3S pattern's name. Identify \uf0c1 bool IsPlayer() -- Checks if object is a player. bool IsNPC() -- Checks if object is an NPC. bool IsHuman() -- Checks if object is a human NPC. bool IsAnimal() -- Checks if object is an animal. (Dog, Cat, Monkey, Motorhead, Rhino, Pigeon) bool IsDog() -- Checks if object is a Dog. bool IsCat() -- Checks if object is a Cat. bool IsMonkey() -- Checks if object is a monkey. (+Motorhead) bool IsMotorhead() -- Checks if object is Motorhead. bool IsProp() -- Checks if object is a prop. (Item, Weapon, Corpse) bool IsItem() -- Checks if object is an item. (Inventory items) bool IsWeapon() -- Checks if object is a weapon. bool IsCorpse() -- Checks if object is a corpse/limb. bool IsVehicle() -- Checks if object is a vehicle. bool IsFSM() -- Checks if object is Anchor, AttackPos, LaserDot, or Effect. bool IsAnchor() -- Checks if object is an Anchor. bool IsAttackPos() -- Checks if object is attack pos. bool IsLaserDot() -- Checks if object is laser dot. bool IsEffect() -- Checks if object is effect. Stimuli \uf0c1 void KnockOut(CP3SObj@ attacker = null) -- Knocks the object out. Attacker is optional. void Suicide(CP3SObj@ attacker = null) -- Kills the object. Attacker is optional. void Relationship(CP3SObj@ ent, int disp, int prio) -- Sets the relationship towards an object. bool CanSee(CP3SObj@ ent, bool bFOV = true) -- Checks if object can see the entity. If bFOV is false, then it checks if vision is obstructed. void Follow(bool bEnabled, int iMode = 0, double fDist = 0.0f) -- Forces the object to follow it's current target. Modes void MoveToTarget(int movementType, int face, int flags, double fDist, double fAngle, double flLeaderAdvanceTime = 0.0f, bool bScriptCommand = true) -- Forces the object to move to it's current target. ( Face types | Movement types ) bool IsOnFire() -- Checks if object is on fire. void Ignite(CBaseEntity@ activator, float flFlameLifetime, bool bNPCOnly, float flSize, bool bCalledByLevelDesigner) -- Ignites the object. void Extinguish() -- Extinguishes the object. Inventory \uf0c1 bool HasWeapon(int weaponId, bool bAmmoCheck = true) -- Checks if object has a weapon. Ammo check is only needed for players. Weapon IDs bool HasHeldWeapon() -- Checks if object is holding a weapon. bool HasHeldItem() -- Checks if object is holding an item. int GetAmmoCount(int ammoIndex) -- Gets the ammo count. Appearance \uf0c1 int Sequence(string&in seq, float dur, int flags = 0) -- Starts a sequence. (NPC only) Returns 1 if it was successful. Flags void ResetSequence() -- Resets current sequence. (NPC only) int Say(string&in sentence, int priority = 0) -- Makes the object say a sentence. Priority Flags void EmitSound(string&in name) -- Plays a sound. Equivalent to Postal3Script's EmitSound. Other \uf0c1 void TeleportTo(CP3SObj@ ent) -- Teleports the object to an object. void AngelScript(string&in sClass, string&in sFunc, CP3SObj@ caller = null) -- Executes AngelScript calls for this object. void Headblob(string&in hbName) -- Sets Headblob. float GetTargetDot(CBaseEntity@ target) -- Gets the dot between target.","title":"CP3SObj@"},{"location":"objects/cp3sobj/#cp3sobj","text":"The scripting entity which is attached to all POSTAL3 entities, this is what Postal3Script is using for it's scripting.","title":"CP3SObj@"},{"location":"objects/cp3sobj/#methods","text":"","title":"Methods"},{"location":"objects/cp3sobj/#attributes","text":"int GetAttr(const string&in sAttr) -- Gets the value of an entity. bool HasAttr(const string&in sAttr) -- Checks if an attribute exists. bool SetAttr(const string&in sAttr, int val, int min = -1, int max = 100) -- Sets or creates an attribute with values specified. bool RemoveAttr(const string&in sAttr) -- Removes an attribute if it exists.","title":"Attributes"},{"location":"objects/cp3sobj/#pointers","text":"CBaseEntity@ GetBaseEntity() -- Gets the base entity pointer. CP3SObj@ GetTarget() -- Gets the current P3S target. CP3SObj@ GetCaller() -- Gets the current P3S caller. CP3SObj@ GetMemory(int iSlot) -- Gets the object from a memory slot, if it exists. Min: 0 Max: 15 CP3SObj@ GetWeapon() -- Gets the held weapon, if there's any. CP3SObj@ GetAnchor() -- Gets the anchor, if there's any. CP3SObj@ GetItem() -- Gets currently held item, if there's any. CP3Weapon@ GetWeaponPtr() -- Gets the weapon pointer for the object's weapon. For Player it is always the active weapon, for NPCs it is always the Melee or Ranged weapon stored.","title":"Pointers"},{"location":"objects/cp3sobj/#targeting","text":"void SetTarget(CP3SObj@ ent) -- Sets P3S target. void SetEnemy(CP3SObj@ pEnemy, bool bSetCondNewEnemy = true) -- Sets the enemy. void SetCaller(CP3SObj@ ent) -- Sets P3S caller. void SetMemory(CP3SObj@ ent, int iSlot) -- Saves an object to the memory slot. Min: 0 Max: 15 void Ignore(CP3SObj@ ent, float flTime) -- Ignores an object for a specified amount of time. bool IsIgnored(CP3SObj@ ent) -- Checks if object is already ignored.","title":"Targeting"},{"location":"objects/cp3sobj/#states-patterns","text":"bool State(string&in sState) -- Sets the P3S state. bool Pattern(string&in sPattern) -- Sets the P3S pattern, from it's current P3S state. void ExecutePattern(string&in sXptPattern) -- Executes a P3S pattern externally. void FireEvent(string&in sEvent, CP3SObj@ obj = null) -- Fires a P3S event, caller(obj) is optional. bool HasAI() -- Checks if entity has a behavior defined.","title":"States, Patterns"},{"location":"objects/cp3sobj/#timers","text":"bool GetTimer(string&in timerName) -- Checks if Timer exists. void SetTimer(string&in timerName, float flTime, bool bRepeated) -- Sets a Timer, seconds, and should it repeat. float GetTimerVal(string&in timerName) -- Gets a Timer's current interval (seconds). 0 or below means the Timer has elapsed. float GetTimerFreq(string&in timerName) -- Gets the Timer's frequency. bool IsTimerRepeated(string&in timerName) -- Checks if Timer is repeated.","title":"Timers"},{"location":"objects/cp3sobj/#data","text":"void SetBehavior(string&in Behavior, string& Manner = null, string& Faction = null, string& Init = null, string& Start = null) -- Sets the new behavior for the object. string GetManner() -- Gets the manner's name. string GetFaction() -- Gets the faction's name. string GetCurState() -- Gets the current P3S state's name. string GetCurGroup() -- Gets the current P3S state's group's name. (Neutral, Alert, Combat) string GetBehavior() -- Gets the behavior name. string GetInherit() -- Gets the inherited behavior name, if there's any. string GetCurPattern() -- Gets the current P3S pattern's name.","title":"Data"},{"location":"objects/cp3sobj/#identify","text":"bool IsPlayer() -- Checks if object is a player. bool IsNPC() -- Checks if object is an NPC. bool IsHuman() -- Checks if object is a human NPC. bool IsAnimal() -- Checks if object is an animal. (Dog, Cat, Monkey, Motorhead, Rhino, Pigeon) bool IsDog() -- Checks if object is a Dog. bool IsCat() -- Checks if object is a Cat. bool IsMonkey() -- Checks if object is a monkey. (+Motorhead) bool IsMotorhead() -- Checks if object is Motorhead. bool IsProp() -- Checks if object is a prop. (Item, Weapon, Corpse) bool IsItem() -- Checks if object is an item. (Inventory items) bool IsWeapon() -- Checks if object is a weapon. bool IsCorpse() -- Checks if object is a corpse/limb. bool IsVehicle() -- Checks if object is a vehicle. bool IsFSM() -- Checks if object is Anchor, AttackPos, LaserDot, or Effect. bool IsAnchor() -- Checks if object is an Anchor. bool IsAttackPos() -- Checks if object is attack pos. bool IsLaserDot() -- Checks if object is laser dot. bool IsEffect() -- Checks if object is effect.","title":"Identify"},{"location":"objects/cp3sobj/#stimuli","text":"void KnockOut(CP3SObj@ attacker = null) -- Knocks the object out. Attacker is optional. void Suicide(CP3SObj@ attacker = null) -- Kills the object. Attacker is optional. void Relationship(CP3SObj@ ent, int disp, int prio) -- Sets the relationship towards an object. bool CanSee(CP3SObj@ ent, bool bFOV = true) -- Checks if object can see the entity. If bFOV is false, then it checks if vision is obstructed. void Follow(bool bEnabled, int iMode = 0, double fDist = 0.0f) -- Forces the object to follow it's current target. Modes void MoveToTarget(int movementType, int face, int flags, double fDist, double fAngle, double flLeaderAdvanceTime = 0.0f, bool bScriptCommand = true) -- Forces the object to move to it's current target. ( Face types | Movement types ) bool IsOnFire() -- Checks if object is on fire. void Ignite(CBaseEntity@ activator, float flFlameLifetime, bool bNPCOnly, float flSize, bool bCalledByLevelDesigner) -- Ignites the object. void Extinguish() -- Extinguishes the object.","title":"Stimuli"},{"location":"objects/cp3sobj/#inventory","text":"bool HasWeapon(int weaponId, bool bAmmoCheck = true) -- Checks if object has a weapon. Ammo check is only needed for players. Weapon IDs bool HasHeldWeapon() -- Checks if object is holding a weapon. bool HasHeldItem() -- Checks if object is holding an item. int GetAmmoCount(int ammoIndex) -- Gets the ammo count.","title":"Inventory"},{"location":"objects/cp3sobj/#appearance","text":"int Sequence(string&in seq, float dur, int flags = 0) -- Starts a sequence. (NPC only) Returns 1 if it was successful. Flags void ResetSequence() -- Resets current sequence. (NPC only) int Say(string&in sentence, int priority = 0) -- Makes the object say a sentence. Priority Flags void EmitSound(string&in name) -- Plays a sound. Equivalent to Postal3Script's EmitSound.","title":"Appearance"},{"location":"objects/cp3sobj/#other","text":"void TeleportTo(CP3SObj@ ent) -- Teleports the object to an object. void AngelScript(string&in sClass, string&in sFunc, CP3SObj@ caller = null) -- Executes AngelScript calls for this object. void Headblob(string&in hbName) -- Sets Headblob. float GetTargetDot(CBaseEntity@ target) -- Gets the dot between target.","title":"Other"},{"location":"objects/cp3weapon/","text":"CP3Weapon@ \uf0c1 The base entity of all POSTAL3 weapons. Methods \uf0c1 CP3SObj@ GetP3SObj() -- Gets the P3S object of the entity. int GetWeaponID() -- Gets the weapon's id. CWPNData& GetWpnData() -- Gets the weapon data pointer of the entity. bool IsAttacking() -- Checks if weapon's owner is currently attacking.","title":"CP3Weapon@"},{"location":"objects/cp3weapon/#cp3weapon","text":"The base entity of all POSTAL3 weapons.","title":"CP3Weapon@"},{"location":"objects/cp3weapon/#methods","text":"CP3SObj@ GetP3SObj() -- Gets the P3S object of the entity. int GetWeaponID() -- Gets the weapon's id. CWPNData& GetWpnData() -- Gets the weapon data pointer of the entity. bool IsAttacking() -- Checks if weapon's owner is currently attacking.","title":"Methods"},{"location":"objects/cparticlesystem/","text":"CParticleSystem@ \uf0c1 The particle system of Source Engine games. Methods \uf0c1 CBaseEntity@ GetBaseEntity() void Start() -- Starts the particle. void Stop() -- Stops the particle.","title":"CParticleSystem@"},{"location":"objects/cparticlesystem/#cparticlesystem","text":"The particle system of Source Engine games.","title":"CParticleSystem@"},{"location":"objects/cparticlesystem/#methods","text":"CBaseEntity@ GetBaseEntity() void Start() -- Starts the particle. void Stop() -- Stops the particle.","title":"Methods"},{"location":"objects/cphysobj/","text":"CPhysObj@ \uf0c1 Physics pointer of an entity. Methods \uf0c1 CBaseEntity@ GetEntity() void Sleep() void Wake() void GetPosition(Vector worldPosition, QAngle angles) void EnableMotion(bool enable) void EnableCollisions(bool enable) void EnableDrag(bool enable) void EnableGravity(bool enable) Velocity \uf0c1 void GetVelocity(Vector velocity, AngularImpulse angularVelocity) void SetVelocity(Vector velocity, AngularImpulse angularVelocity) void SetVelocityInstant(Vector velocity, AngularImpulse angularVelocity) void AddVelocity(Vector velocity, AngularImpulse angularVelocity) Inertia, Mass \uf0c1 void SetInertia(Vector inertia) void SetMass(double mass) Vector GetInertia() double GetMass() State \uf0c1 bool IsAsleep() bool IsCollisionEnabled() bool IsDragEnabled() bool IsFluid() bool IsGravityEnabled() bool IsHinged() bool IsMotionEnabled() bool IsMoveable() bool IsStatic() bool IsTrigger()","title":"CPhysObj@"},{"location":"objects/cphysobj/#cphysobj","text":"Physics pointer of an entity.","title":"CPhysObj@"},{"location":"objects/cphysobj/#methods","text":"CBaseEntity@ GetEntity() void Sleep() void Wake() void GetPosition(Vector worldPosition, QAngle angles) void EnableMotion(bool enable) void EnableCollisions(bool enable) void EnableDrag(bool enable) void EnableGravity(bool enable)","title":"Methods"},{"location":"objects/cphysobj/#velocity","text":"void GetVelocity(Vector velocity, AngularImpulse angularVelocity) void SetVelocity(Vector velocity, AngularImpulse angularVelocity) void SetVelocityInstant(Vector velocity, AngularImpulse angularVelocity) void AddVelocity(Vector velocity, AngularImpulse angularVelocity)","title":"Velocity"},{"location":"objects/cphysobj/#inertia-mass","text":"void SetInertia(Vector inertia) void SetMass(double mass) Vector GetInertia() double GetMass()","title":"Inertia, Mass"},{"location":"objects/cphysobj/#state","text":"bool IsAsleep() bool IsCollisionEnabled() bool IsDragEnabled() bool IsFluid() bool IsGravityEnabled() bool IsHinged() bool IsMotionEnabled() bool IsMoveable() bool IsStatic() bool IsTrigger()","title":"State"},{"location":"objects/csoundpatch/","text":"CSoundPatch@ \uf0c1 Sound.","title":"CSoundPatch@"},{"location":"objects/csoundpatch/#csoundpatch","text":"Sound.","title":"CSoundPatch@"},{"location":"objects/ctakedamageinfo/","text":"CTakeDamageInfo@ \uf0c1 Take Damage info. Methods \uf0c1 Getters \uf0c1 CBaseEntity@ GetInflictor() CBaseEntity@ GetWeapon() CBaseEntity@ GetAttacker() double GetDamage() double GetDamage() const double GetMaxDamage() double GetMaxDamage() const double GetBaseDamage() double GetBaseDamage() const bool BaseDamageIsValid() Vector GetDamagePosition() Vector GetReportedPosition() Vector GetDamageForce() int GetDamageType() int GetDamageCustom() int GetDamageStats() int GetAmmoType() string GetAmmoName() int GetDamagedOtherPlayers() bool GetCanCrit() bool GetHandleDamageLikeRagdoll() Setters \uf0c1 void SetDamage(double flDamage) void SetMaxDamage(double flMaxDamage) void SetInflictor(CBaseEntity@ pInflictor) void SetAttacker(CBaseEntity@ pAttacker) void SetWeapon(CBaseEntity@ pWeapon) void SetReportedPosition(Vector reportedPosition) void SetAmmoType(int iAmmoType) void SetDamageType(int bitsDamageType) void AddDamageType(int bitsDamageType) void ScaleDamage(double flScaleAmount) void AddDamage(double flAddAmount) void SubtractDamage(double flSubtractAmount) void SetDamageForce(Vector damageForce) void ScaleDamageForce(double flScaleAmount) void SetDamagePosition(Vector damagePosition) void SetDamageCustom(int iDamageCustom) void SetDamageStats(int iDamageStats) void AdjustPlayerDamageInflictedForSkillLevel() void AdjustPlayerDamageTakenForSkillLevel() void SetDamagedOtherPlayers(int iVal) void SetCanCrit(bool val) void SetHandleDamageLikeRagdoll(bool val) void CopyDamageToBaseDamage()","title":"CTakeDamageInfo@"},{"location":"objects/ctakedamageinfo/#ctakedamageinfo","text":"Take Damage info.","title":"CTakeDamageInfo@"},{"location":"objects/ctakedamageinfo/#methods","text":"","title":"Methods"},{"location":"objects/ctakedamageinfo/#getters","text":"CBaseEntity@ GetInflictor() CBaseEntity@ GetWeapon() CBaseEntity@ GetAttacker() double GetDamage() double GetDamage() const double GetMaxDamage() double GetMaxDamage() const double GetBaseDamage() double GetBaseDamage() const bool BaseDamageIsValid() Vector GetDamagePosition() Vector GetReportedPosition() Vector GetDamageForce() int GetDamageType() int GetDamageCustom() int GetDamageStats() int GetAmmoType() string GetAmmoName() int GetDamagedOtherPlayers() bool GetCanCrit() bool GetHandleDamageLikeRagdoll()","title":"Getters"},{"location":"objects/ctakedamageinfo/#setters","text":"void SetDamage(double flDamage) void SetMaxDamage(double flMaxDamage) void SetInflictor(CBaseEntity@ pInflictor) void SetAttacker(CBaseEntity@ pAttacker) void SetWeapon(CBaseEntity@ pWeapon) void SetReportedPosition(Vector reportedPosition) void SetAmmoType(int iAmmoType) void SetDamageType(int bitsDamageType) void AddDamageType(int bitsDamageType) void ScaleDamage(double flScaleAmount) void AddDamage(double flAddAmount) void SubtractDamage(double flSubtractAmount) void SetDamageForce(Vector damageForce) void ScaleDamageForce(double flScaleAmount) void SetDamagePosition(Vector damagePosition) void SetDamageCustom(int iDamageCustom) void SetDamageStats(int iDamageStats) void AdjustPlayerDamageInflictedForSkillLevel() void AdjustPlayerDamageTakenForSkillLevel() void SetDamagedOtherPlayers(int iVal) void SetCanCrit(bool val) void SetHandleDamageLikeRagdoll(bool val) void CopyDamageToBaseDamage()","title":"Setters"},{"location":"objects/cwpndata/","text":"CWPNData@ \uf0c1 The data that's embedded into all weapons on game startup. Properties \uf0c1 string szPrimaryAmmo() string szSecondaryAmmo() float flPrimaryMinDamage float flPrimaryMaxDamage float flSecondaryMinDamage float flSecondaryMaxDamage float flNPCMinDamage float flNPCMaxDamage int iSlot int iPosition int iMaxClip1 int iMaxClip2 int iDefaultClip1 int iDefaultClip2 int iWeight bool bAutoSwitchTo bool bAutoSwitchFrom int iFlags int iAmmoType int iAmmo2Type float flFireRate1 float flFireRate2","title":"CWPNData@"},{"location":"objects/cwpndata/#cwpndata","text":"The data that's embedded into all weapons on game startup.","title":"CWPNData@"},{"location":"objects/cwpndata/#properties","text":"string szPrimaryAmmo() string szSecondaryAmmo() float flPrimaryMinDamage float flPrimaryMaxDamage float flSecondaryMinDamage float flSecondaryMaxDamage float flNPCMinDamage float flNPCMaxDamage int iSlot int iPosition int iMaxClip1 int iMaxClip2 int iDefaultClip1 int iDefaultClip2 int iWeight bool bAutoSwitchTo bool bAutoSwitchFrom int iFlags int iAmmoType int iAmmo2Type float flFireRate1 float flFireRate2","title":"Properties"},{"location":"objects/ehandle/","text":"EHANDLE \uf0c1 Methods: \uf0c1 CBaseEntity@ GetEntity() const int GetSerialNumber() const bool IsValid() const","title":"EHANDLE"},{"location":"objects/ehandle/#ehandle","text":"","title":"EHANDLE"},{"location":"objects/ehandle/#methods","text":"CBaseEntity@ GetEntity() const int GetSerialNumber() const bool IsValid() const","title":"Methods:"},{"location":"objects/hintnodedata/","text":"HintNodeData@ \uf0c1 Variables \uf0c1 string_t strEntityName Vector vecPosition int16 nHintType int nNodeID string_t strGroup int iDisabled NPC_STATE minState string_t iszActivityName NPC_STATE maxState int nTargetWCNodeID int nWCNodeID HintIgnoreFacing_t fIgnoreFacing","title":"HintNodeData@"},{"location":"objects/hintnodedata/#hintnodedata","text":"","title":"HintNodeData@"},{"location":"objects/hintnodedata/#variables","text":"string_t strEntityName Vector vecPosition int16 nHintType int nNodeID string_t strGroup int iDisabled NPC_STATE minState string_t iszActivityName NPC_STATE maxState int nTargetWCNodeID int nWCNodeID HintIgnoreFacing_t fIgnoreFacing","title":"Variables"},{"location":"objects/keyvalues/","text":"KeyValues@ \uf0c1 Key values. Can be used to read and write to .txt files. Methods \uf0c1 bool LoadFromFile(string&in filePath) KeyValues@ FindKey(string&in keyName, bool bCreate = false) string GetName() string GetString(string&in keyName = \"\", string&in defaultValue = \"\") string IsEmpty(string&in keyName = \"\") KeyValues@ GetFirstSubKey() KeyValues@ GetNextKey() KeyValues@ GetFirstTrueSubKey() KeyValues@ GetNextTrueSubKey() KeyValues@ GetFirstValue() KeyValues@ GetNextValue() void deleteThis()","title":"KeyValues@"},{"location":"objects/keyvalues/#keyvalues","text":"Key values. Can be used to read and write to .txt files.","title":"KeyValues@"},{"location":"objects/keyvalues/#methods","text":"bool LoadFromFile(string&in filePath) KeyValues@ FindKey(string&in keyName, bool bCreate = false) string GetName() string GetString(string&in keyName = \"\", string&in defaultValue = \"\") string IsEmpty(string&in keyName = \"\") KeyValues@ GetFirstSubKey() KeyValues@ GetNextKey() KeyValues@ GetFirstTrueSubKey() KeyValues@ GetNextTrueSubKey() KeyValues@ GetFirstValue() KeyValues@ GetNextValue() void deleteThis()","title":"Methods"},{"location":"tutorials/asinp3s/","text":"Calling AngelScript in Postal3Script \uf0c1 Class and Function execution \uf0c1 This tutorial is briefly explained on the Using AngelScript page. AngelScript code can be used/called inside Postal3Script, here's how in an example: In Postal3Script: xpt_CheckCallerNPC { actions { TargetCaller 1 SetAttr \"checkresult 0\" AngelScript \"Object:self Misc xpt_CheckCallerNPC\" IfAttr \"checkresult == 1 Block begin\" // do something according to the result... Block end } } In AngelScript: class Misc : IPostal3Script { void xpt_CheckCallerNPC() { // Note: the context owner is always the one who called the function from P3S! CP3SObj@ self = GetContextOwner(); // We can't check without 'self' if (self == null) return; // Doesn't have any target if (self.GetTarget() == null) return; if (self.GetTarget().IsNPC() == true) bResult = true; if (bResult == true) self.SetAttr(\"checkresult\", 1); } } Function-only execution \uf0c1 You can also just specify the function name, but when you do that the class name must match the executioner's behavior name from P3S. You should only use this when you are 100% sure the behavior name won't change, for example, if you are trying to call the AngelScript function in a class that's inherited from, it'll always be the main, current behavior name, the console will always warn you if it tries to execute an unknown function from a(n) (unknown) class. It's highly recommended you also use class when executing. In Postal3Script: behavior { name bh_mybehavior States { st_init { Group Neutral Patterns { pt_default { actions { AngelScript \"Object:self Setup\" } } } } } } In AngelScript: class bh_mybehavior : IPostal3Script { // st_init in AngelScript, kinda ... void Setup() { // Note: the context owner is always the one who called the function from P3S! CP3SObj@ self = GetContextOwner(); if (self == null) return; self.SetAttr(\"NPC\", 0); self.SetAttr(\"Dog\", 0); self.SetAttr(\"Cat\", 0); self.SetAttr(\"Human\", 0); self.SetAttr(\"Player\", 0); if (self.IsNPC()) { self.SetAttr(\"NPC\", 1); if (self.IsDog()) self.SetAttr(\"Dog\", 1); else if (self.IsCat()) self.SetAttr(\"Cat\", 1); else if (self.IsHuman()) self.SetAttr(\"Human\", 1); } else if (self.IsPlayer()) self.SetAttr(\"Player\", 1); } }","title":"Calling AngelScript in Postal3Script"},{"location":"tutorials/asinp3s/#calling-angelscript-in-postal3script","text":"","title":"Calling AngelScript in Postal3Script"},{"location":"tutorials/asinp3s/#class-and-function-execution","text":"This tutorial is briefly explained on the Using AngelScript page. AngelScript code can be used/called inside Postal3Script, here's how in an example: In Postal3Script: xpt_CheckCallerNPC { actions { TargetCaller 1 SetAttr \"checkresult 0\" AngelScript \"Object:self Misc xpt_CheckCallerNPC\" IfAttr \"checkresult == 1 Block begin\" // do something according to the result... Block end } } In AngelScript: class Misc : IPostal3Script { void xpt_CheckCallerNPC() { // Note: the context owner is always the one who called the function from P3S! CP3SObj@ self = GetContextOwner(); // We can't check without 'self' if (self == null) return; // Doesn't have any target if (self.GetTarget() == null) return; if (self.GetTarget().IsNPC() == true) bResult = true; if (bResult == true) self.SetAttr(\"checkresult\", 1); } }","title":"Class and Function execution"},{"location":"tutorials/asinp3s/#function-only-execution","text":"You can also just specify the function name, but when you do that the class name must match the executioner's behavior name from P3S. You should only use this when you are 100% sure the behavior name won't change, for example, if you are trying to call the AngelScript function in a class that's inherited from, it'll always be the main, current behavior name, the console will always warn you if it tries to execute an unknown function from a(n) (unknown) class. It's highly recommended you also use class when executing. In Postal3Script: behavior { name bh_mybehavior States { st_init { Group Neutral Patterns { pt_default { actions { AngelScript \"Object:self Setup\" } } } } } } In AngelScript: class bh_mybehavior : IPostal3Script { // st_init in AngelScript, kinda ... void Setup() { // Note: the context owner is always the one who called the function from P3S! CP3SObj@ self = GetContextOwner(); if (self == null) return; self.SetAttr(\"NPC\", 0); self.SetAttr(\"Dog\", 0); self.SetAttr(\"Cat\", 0); self.SetAttr(\"Human\", 0); self.SetAttr(\"Player\", 0); if (self.IsNPC()) { self.SetAttr(\"NPC\", 1); if (self.IsDog()) self.SetAttr(\"Dog\", 1); else if (self.IsCat()) self.SetAttr(\"Cat\", 1); else if (self.IsHuman()) self.SetAttr(\"Human\", 1); } else if (self.IsPlayer()) self.SetAttr(\"Player\", 1); } }","title":"Function-only execution"},{"location":"tutorials/cache/","text":"Cache \uf0c1 Cache is implemented as of 03.04.2023, it makes the function GetContextOwner a bit redundant. It is very important because script classes can have memory, and their state won't get lost after executing one of their function again. How it works, explanation \uf0c1 You call the AngelScript P3S function via like this: AngelScript \"Object:self MyClass MyFunction\" The script class looks something like this: class MyClass : IPostal3Script { CP3SObj@ self; MyClass(CP3SObj@ obj) { @self = obj; } void MyFunction() { // ... } } The game first checks if there's already a cached instance of the class named MyClass with the context owner's pointer. If not, then it will first create the factory , in the example above that is called MyClass(CP3SObj@ obj) , this will always gets called first, before eventually executing MyFunction() . In the factory you can set up initialization things such as making sure the self handle is assigned to the entity that called AngelScript. Global (no owner) \uf0c1 Global version (basically no owner is attached) would look something like this in P3S: AngelScript \"GLOBAL MyClass Increment\" Then the script class would look something like this: class MyClass : IPostal3Script { int num; CP3SObj@ caller; MyClass() { num = 0; } void Increment() { num++; Printf(\"Incremented: %d\\n\", num); } } No matter from which entity it was called from, the variable num would never start again from 0 in the example above. Only disadvantage is that you will never know which entity called this function. Variables don't get lost after executing twice \uf0c1 Script classes will hold all the variables you set previously, if the context owner is the same. If there is no context owner (i.e. engine functions, like SEngine::FireGameEvent(IGameEvent @evt) ) then cache will only look up for the class name. You can still check for the context owner via GetContextOwner . For example: class MyClass : IPostal3Script { CP3SObj@ self; MyClass(CP3SObj@ obj) { @self = obj; } bool bBoolean; void MyFunction() { if (bBoolean == false) Printf(\"Boolean is false!\\n\"); else Printf(\"Boolean is true!\\n\"); bBoolean = true; } } Executing MyFunction() first will print out the message Boolean is false! to the console, but if you execute it twice, it'll say Boolean is true! on the same entity it was executed from in the first place. No Serialization, Restoration \uf0c1 Outdated Section This part of the tutorial is outdated, it was written when AngelScript had no serialization. While the information here is not that useless, we don't really recommend using this method for restoration. Check the Serialization page for more information. AngelScript in Catharsis Reborn do not have serialization , this means whenever you save the game and reload it (or go through a transition), AngelScript's memory will be wiped. You can tell AngelScript which entities you wish to be \"restored\" whenever the game was reloaded via a save file, or when the Player went through a transition with the following P3S attributes: Postal3Script Attribute Postal3Script Event as_restore OnASRestore as_transition OnASTransition as_restore will call OnASRestore P3S event when the game was reloaded via a save file. as_transition will call OnASTransition P3S event when the game was a transition load type. Using these two attributes you can then attempt restoration by reinitializing their classes, like this: // Executed from OnASRestore and OnASTransition P3S events xpt_restore { actions { // Have to always remove attribute as_init_<className> !! RemoveAttr \"as_init_CATM\" AngelScript \"Init Object:self CATM\" } } Depending on the complexity of your entity, you will also have to edit AngelScript code to reattach important things. While AngelScript will never be saved to disk, Postal3Script will do, and it's highly recommended to save P3S attributes inside the entity.","title":"Cache"},{"location":"tutorials/cache/#cache","text":"Cache is implemented as of 03.04.2023, it makes the function GetContextOwner a bit redundant. It is very important because script classes can have memory, and their state won't get lost after executing one of their function again.","title":"Cache"},{"location":"tutorials/cache/#how-it-works-explanation","text":"You call the AngelScript P3S function via like this: AngelScript \"Object:self MyClass MyFunction\" The script class looks something like this: class MyClass : IPostal3Script { CP3SObj@ self; MyClass(CP3SObj@ obj) { @self = obj; } void MyFunction() { // ... } } The game first checks if there's already a cached instance of the class named MyClass with the context owner's pointer. If not, then it will first create the factory , in the example above that is called MyClass(CP3SObj@ obj) , this will always gets called first, before eventually executing MyFunction() . In the factory you can set up initialization things such as making sure the self handle is assigned to the entity that called AngelScript.","title":"How it works, explanation"},{"location":"tutorials/cache/#global-no-owner","text":"Global version (basically no owner is attached) would look something like this in P3S: AngelScript \"GLOBAL MyClass Increment\" Then the script class would look something like this: class MyClass : IPostal3Script { int num; CP3SObj@ caller; MyClass() { num = 0; } void Increment() { num++; Printf(\"Incremented: %d\\n\", num); } } No matter from which entity it was called from, the variable num would never start again from 0 in the example above. Only disadvantage is that you will never know which entity called this function.","title":"Global (no owner)"},{"location":"tutorials/cache/#variables-dont-get-lost-after-executing-twice","text":"Script classes will hold all the variables you set previously, if the context owner is the same. If there is no context owner (i.e. engine functions, like SEngine::FireGameEvent(IGameEvent @evt) ) then cache will only look up for the class name. You can still check for the context owner via GetContextOwner . For example: class MyClass : IPostal3Script { CP3SObj@ self; MyClass(CP3SObj@ obj) { @self = obj; } bool bBoolean; void MyFunction() { if (bBoolean == false) Printf(\"Boolean is false!\\n\"); else Printf(\"Boolean is true!\\n\"); bBoolean = true; } } Executing MyFunction() first will print out the message Boolean is false! to the console, but if you execute it twice, it'll say Boolean is true! on the same entity it was executed from in the first place.","title":"Variables don't get lost after executing twice"},{"location":"tutorials/cache/#no-serialization-restoration","text":"Outdated Section This part of the tutorial is outdated, it was written when AngelScript had no serialization. While the information here is not that useless, we don't really recommend using this method for restoration. Check the Serialization page for more information. AngelScript in Catharsis Reborn do not have serialization , this means whenever you save the game and reload it (or go through a transition), AngelScript's memory will be wiped. You can tell AngelScript which entities you wish to be \"restored\" whenever the game was reloaded via a save file, or when the Player went through a transition with the following P3S attributes: Postal3Script Attribute Postal3Script Event as_restore OnASRestore as_transition OnASTransition as_restore will call OnASRestore P3S event when the game was reloaded via a save file. as_transition will call OnASTransition P3S event when the game was a transition load type. Using these two attributes you can then attempt restoration by reinitializing their classes, like this: // Executed from OnASRestore and OnASTransition P3S events xpt_restore { actions { // Have to always remove attribute as_init_<className> !! RemoveAttr \"as_init_CATM\" AngelScript \"Init Object:self CATM\" } } Depending on the complexity of your entity, you will also have to edit AngelScript code to reattach important things. While AngelScript will never be saved to disk, Postal3Script will do, and it's highly recommended to save P3S attributes inside the entity.","title":"No Serialization, Restoration"},{"location":"tutorials/contextcreation/","text":"Creating new contexts in script \uf0c1 With CreateContext or CreateContextClass you can create a new instance of context (code/script execution), which will run in parellel and you are able to use Wait independently, which won't affect the main context it was called from. If you are simply just calling a function with no arguments, AngelScript will have no problems with that, but you'll have some problems the moment you try to pass in objects or datatypes. Here's an example how you can avoid crashes when passing arguments into CreateContext: (Note: this is an old tutorial, and a very hacky way to do this, use DelayedExecution and GetScriptObj instead!) class A : IPostal3Script { void main() { CP3SObj@ self = GetContextOwner(); // Store the 'self' handle any ObjStorage; ObjStorage.store(@self); CreateContextClass(\"B\", \"MyFunction\", ObjStorage); } } class B : IPostal3Script { void MyFunction(any ObjStorage) { CP3SObj@ obj = null; if (ObjStorage.retrieve(@obj) == false) return; // From this point on the function will only continue // if the @obj handle was compatible, thus avoiding crashes // Kill this object. if (obj.IsNPC() == true) obj.SetAttr(\"ea_health\", 0); } } Passing multiple arguments: class A : IPostal3Script { void main() { CP3SObj@ self = GetContextOwner(); int num = 1; bool tf = false; any ObjStorage; any IntStorage; any BoolStorage; // Store stuff ObjStorage.store(@self); IntStorage.store(num); BoolStorage.store(tf); // Arguments must match B's MyFunction function's args! CreateContextClass(\"B\", \"MyFunction\", ObjStorage, IntStorage, BoolStorage); } } class B : IPostal3Script { // Are the arguments we are trying to pass in via CreateContextClass correct here? void MyFunction(any ObjStorage, any IntStorage, BoolStorage) { CP3SObj@ obj = null; int num = 0; bool tf = true; if (ObjStorage.retrieve(@obj) == false) return; // We are confident with our integers and booleans, so we don't need to check IntStorage.retrieve(num); BoolStorage.retrieve(tf); // From this point on the function will only continue // if the @obj handle was compatible, thus avoiding crashes // num will be 1 here if (num > 0) { CP3SObj@ pPlayer = GetPlayer(); obj.TeleportTo(pPlayer); // tf will be false here if (tf == true) { // Give enough time for the object to teleport... Wait(1.75); obj.FireEvent(\"OnHearCombat\", pPlayer); } } } } Delayed Execution \uf0c1 You can also use DelayedExecution which can execute contexts with delay. A delay of 0 will be instantaneous. Here's an example, a class is initiated on spawn when the Player is still looking at the loading screen, we want to execute a function when we are sure the Player is fully loaded in: // Yeah it's called Personal Computer Computer, problem? class Example : IPostal3Script { // Dummy void Init(){} CP3SObj@ self; Example(CP3SObj@ obj) { @self = @obj; engine.DelayedExecution(0, \"Example\", \"Test\", self); } // This will execute when the Player is no longer loading! void Test() { CP3SObj@ mon = null; array<CP3SObj@> aNPC = engine.GetArrayOfEntitiesRadius(self, 96); for (uint i = 0; i < aNPC.length(); i++) { if ( @aNPC[i] == null ) continue; if ( @aNPC[i] == @self ) continue; if ( aNPC[i].GetBaseEntity().GetClassName() != \"cr_prop_interactable\" ) continue; if ( aNPC[i].GetManner() != \"PCMonitor\" ) continue; @mon = @aNPC[i]; break; } if (mon != null) Printf(\"mon is not null!\\n\"); else Printf(\"mon is null!\\n\"); } }","title":"Creating Contexts"},{"location":"tutorials/contextcreation/#creating-new-contexts-in-script","text":"With CreateContext or CreateContextClass you can create a new instance of context (code/script execution), which will run in parellel and you are able to use Wait independently, which won't affect the main context it was called from. If you are simply just calling a function with no arguments, AngelScript will have no problems with that, but you'll have some problems the moment you try to pass in objects or datatypes. Here's an example how you can avoid crashes when passing arguments into CreateContext: (Note: this is an old tutorial, and a very hacky way to do this, use DelayedExecution and GetScriptObj instead!) class A : IPostal3Script { void main() { CP3SObj@ self = GetContextOwner(); // Store the 'self' handle any ObjStorage; ObjStorage.store(@self); CreateContextClass(\"B\", \"MyFunction\", ObjStorage); } } class B : IPostal3Script { void MyFunction(any ObjStorage) { CP3SObj@ obj = null; if (ObjStorage.retrieve(@obj) == false) return; // From this point on the function will only continue // if the @obj handle was compatible, thus avoiding crashes // Kill this object. if (obj.IsNPC() == true) obj.SetAttr(\"ea_health\", 0); } } Passing multiple arguments: class A : IPostal3Script { void main() { CP3SObj@ self = GetContextOwner(); int num = 1; bool tf = false; any ObjStorage; any IntStorage; any BoolStorage; // Store stuff ObjStorage.store(@self); IntStorage.store(num); BoolStorage.store(tf); // Arguments must match B's MyFunction function's args! CreateContextClass(\"B\", \"MyFunction\", ObjStorage, IntStorage, BoolStorage); } } class B : IPostal3Script { // Are the arguments we are trying to pass in via CreateContextClass correct here? void MyFunction(any ObjStorage, any IntStorage, BoolStorage) { CP3SObj@ obj = null; int num = 0; bool tf = true; if (ObjStorage.retrieve(@obj) == false) return; // We are confident with our integers and booleans, so we don't need to check IntStorage.retrieve(num); BoolStorage.retrieve(tf); // From this point on the function will only continue // if the @obj handle was compatible, thus avoiding crashes // num will be 1 here if (num > 0) { CP3SObj@ pPlayer = GetPlayer(); obj.TeleportTo(pPlayer); // tf will be false here if (tf == true) { // Give enough time for the object to teleport... Wait(1.75); obj.FireEvent(\"OnHearCombat\", pPlayer); } } } }","title":"Creating new contexts in script"},{"location":"tutorials/contextcreation/#delayed-execution","text":"You can also use DelayedExecution which can execute contexts with delay. A delay of 0 will be instantaneous. Here's an example, a class is initiated on spawn when the Player is still looking at the loading screen, we want to execute a function when we are sure the Player is fully loaded in: // Yeah it's called Personal Computer Computer, problem? class Example : IPostal3Script { // Dummy void Init(){} CP3SObj@ self; Example(CP3SObj@ obj) { @self = @obj; engine.DelayedExecution(0, \"Example\", \"Test\", self); } // This will execute when the Player is no longer loading! void Test() { CP3SObj@ mon = null; array<CP3SObj@> aNPC = engine.GetArrayOfEntitiesRadius(self, 96); for (uint i = 0; i < aNPC.length(); i++) { if ( @aNPC[i] == null ) continue; if ( @aNPC[i] == @self ) continue; if ( aNPC[i].GetBaseEntity().GetClassName() != \"cr_prop_interactable\" ) continue; if ( aNPC[i].GetManner() != \"PCMonitor\" ) continue; @mon = @aNPC[i]; break; } if (mon != null) Printf(\"mon is not null!\\n\"); else Printf(\"mon is null!\\n\"); } }","title":"Delayed Execution"},{"location":"tutorials/delaying/","text":"Delaying code executions \uf0c1 We have implemented a function called ' Wait ' for AngelScript, so executions can be delayed like in Postal3Script , however, you have to be very careful with how you write the logic of your script. Let's say, you are creating an entity in map called 'A', you called an input called \"turnon\" on it, and you wish to turn it off, after 7 seconds or so: class Tut : IPostal3Script { void SpawnSmoke(Vector pos) { CBaseEntity@ smoke = FindEntByName(\"reinforcement_smoke\"); if (smoke == null) { CBaseEntity@ ent = CreateEnt(\"env_smokestack\"); if ( ent != null ) { SetKeyValue( ent, \"angles\", \"0\" ); SetKeyValue( ent, \"BaseSpread\", \"60\" ); SetKeyValue( ent, \"EndSize\", \"115\" ); SetKeyValue( ent, \"InitialState\", \"1\" ); SetKeyValue( ent, \"JetLength\", \"150\" ); SetKeyValue( ent, \"Rate\", \"20\" ); SetKeyValue( ent, \"renderamt\", \"255\" ); SetKeyValue( ent, \"rendercolor\", \"45 45 45\" ); SetKeyValue( ent, \"roll\", \"15\" ); SetKeyValue( ent, \"SmokeMaterial\", \"particle/SmokeStack.vmt\" ); SetKeyValue( ent, \"Speed\", \"50\" ); SetKeyValue( ent, \"SpreadSpeed\", \"60\" ); SetKeyValue( ent, \"StartSize\", \"100\" ); SetKeyValue( ent, \"targetname\", \"reinforcement_smoke\" ); SetKeyValue( ent, \"twist\", \"7\" ); SetKeyValue( ent, \"WindAngle\", \"0\" ); SetKeyValue( ent, \"WindSpeed\", \"0\" ); Spawn(ent); ent.Activate(); SetAbsOrigin( ent, pos ); Wait(7.0); FireInput(ent, \"turnoff\"); } } else { FireInput(smoke, \"turnon\"); Wait(7.0); FireInput(smoke, \"turnoff\"); } } } During those 7 seconds the Player might go through a transit zone, after 7 seconds if AS tries to access the ent or smoke object, AngelScript will crash, because an entity created/or accessed in 'A' map doesn't exists in 'B' map! Here's one way of solving the crash involved with the above code: class Tut : IPostal3Script { void SpawnSmoke(Vector pos) { CBaseEntity@ smoke = FindEntByName(\"reinforcement_smoke\"); if (smoke == null) { CBaseEntity@ ent = CreateEnt(\"env_smokestack\"); if ( ent != null ) { SetKeyValue( ent, \"angles\", \"0\" ); SetKeyValue( ent, \"BaseSpread\", \"60\" ); SetKeyValue( ent, \"EndSize\", \"115\" ); SetKeyValue( ent, \"InitialState\", \"1\" ); SetKeyValue( ent, \"JetLength\", \"150\" ); SetKeyValue( ent, \"Rate\", \"20\" ); SetKeyValue( ent, \"renderamt\", \"255\" ); SetKeyValue( ent, \"rendercolor\", \"45 45 45\" ); SetKeyValue( ent, \"roll\", \"15\" ); SetKeyValue( ent, \"SmokeMaterial\", \"particle/SmokeStack.vmt\" ); SetKeyValue( ent, \"Speed\", \"50\" ); SetKeyValue( ent, \"SpreadSpeed\", \"60\" ); SetKeyValue( ent, \"StartSize\", \"100\" ); SetKeyValue( ent, \"targetname\", \"reinforcement_smoke\" ); SetKeyValue( ent, \"twist\", \"7\" ); SetKeyValue( ent, \"WindAngle\", \"0\" ); SetKeyValue( ent, \"WindSpeed\", \"0\" ); Spawn(ent); ent.Activate(); SetAbsOrigin( ent, pos ); // Add a wait handling here. Wait(7.0, WH_FREEZE_MAPNAME); // And if we want to be 100% sure, let's remake the handle @ent = FindEntByName(\"reinforcement_smoke\"); FireInput(ent, \"turnoff\"); } } else { FireInput(smoke, \"turnon\"); // Add a wait handling here. Wait(7.0, WH_FREEZE_MAPNAME); // And if we want to be 100% sure, let's remake the handle @smoke = FindEntByName(\"reinforcement_smoke\"); FireInput(smoke, \"turnoff\"); } } } The only exception is the Player, it'll always be a valid entity after transition. There are several ways handling this: Wait(7.0, WH_ABORT_MAPNAME); -- This will cause the execution to abort if the map name doesn't match after waiting. Wait(7.0, WH_ABORT_LEVELCHANGE); -- The WH_ABORT_LEVELCHANGE one will cause the execution to abort on any kind of level change. Or... Wait(7.0, WH_FREEZE_MAPNAME); -- This will cause the execution to freeze until the map name matches it originally executed from. When you work with entities, just keep this in mind that after a level change some entities in the code execution might become invalid, so it's fine to just simply abort them to avoid any crashes.","title":"Delaying"},{"location":"tutorials/delaying/#delaying-code-executions","text":"We have implemented a function called ' Wait ' for AngelScript, so executions can be delayed like in Postal3Script , however, you have to be very careful with how you write the logic of your script. Let's say, you are creating an entity in map called 'A', you called an input called \"turnon\" on it, and you wish to turn it off, after 7 seconds or so: class Tut : IPostal3Script { void SpawnSmoke(Vector pos) { CBaseEntity@ smoke = FindEntByName(\"reinforcement_smoke\"); if (smoke == null) { CBaseEntity@ ent = CreateEnt(\"env_smokestack\"); if ( ent != null ) { SetKeyValue( ent, \"angles\", \"0\" ); SetKeyValue( ent, \"BaseSpread\", \"60\" ); SetKeyValue( ent, \"EndSize\", \"115\" ); SetKeyValue( ent, \"InitialState\", \"1\" ); SetKeyValue( ent, \"JetLength\", \"150\" ); SetKeyValue( ent, \"Rate\", \"20\" ); SetKeyValue( ent, \"renderamt\", \"255\" ); SetKeyValue( ent, \"rendercolor\", \"45 45 45\" ); SetKeyValue( ent, \"roll\", \"15\" ); SetKeyValue( ent, \"SmokeMaterial\", \"particle/SmokeStack.vmt\" ); SetKeyValue( ent, \"Speed\", \"50\" ); SetKeyValue( ent, \"SpreadSpeed\", \"60\" ); SetKeyValue( ent, \"StartSize\", \"100\" ); SetKeyValue( ent, \"targetname\", \"reinforcement_smoke\" ); SetKeyValue( ent, \"twist\", \"7\" ); SetKeyValue( ent, \"WindAngle\", \"0\" ); SetKeyValue( ent, \"WindSpeed\", \"0\" ); Spawn(ent); ent.Activate(); SetAbsOrigin( ent, pos ); Wait(7.0); FireInput(ent, \"turnoff\"); } } else { FireInput(smoke, \"turnon\"); Wait(7.0); FireInput(smoke, \"turnoff\"); } } } During those 7 seconds the Player might go through a transit zone, after 7 seconds if AS tries to access the ent or smoke object, AngelScript will crash, because an entity created/or accessed in 'A' map doesn't exists in 'B' map! Here's one way of solving the crash involved with the above code: class Tut : IPostal3Script { void SpawnSmoke(Vector pos) { CBaseEntity@ smoke = FindEntByName(\"reinforcement_smoke\"); if (smoke == null) { CBaseEntity@ ent = CreateEnt(\"env_smokestack\"); if ( ent != null ) { SetKeyValue( ent, \"angles\", \"0\" ); SetKeyValue( ent, \"BaseSpread\", \"60\" ); SetKeyValue( ent, \"EndSize\", \"115\" ); SetKeyValue( ent, \"InitialState\", \"1\" ); SetKeyValue( ent, \"JetLength\", \"150\" ); SetKeyValue( ent, \"Rate\", \"20\" ); SetKeyValue( ent, \"renderamt\", \"255\" ); SetKeyValue( ent, \"rendercolor\", \"45 45 45\" ); SetKeyValue( ent, \"roll\", \"15\" ); SetKeyValue( ent, \"SmokeMaterial\", \"particle/SmokeStack.vmt\" ); SetKeyValue( ent, \"Speed\", \"50\" ); SetKeyValue( ent, \"SpreadSpeed\", \"60\" ); SetKeyValue( ent, \"StartSize\", \"100\" ); SetKeyValue( ent, \"targetname\", \"reinforcement_smoke\" ); SetKeyValue( ent, \"twist\", \"7\" ); SetKeyValue( ent, \"WindAngle\", \"0\" ); SetKeyValue( ent, \"WindSpeed\", \"0\" ); Spawn(ent); ent.Activate(); SetAbsOrigin( ent, pos ); // Add a wait handling here. Wait(7.0, WH_FREEZE_MAPNAME); // And if we want to be 100% sure, let's remake the handle @ent = FindEntByName(\"reinforcement_smoke\"); FireInput(ent, \"turnoff\"); } } else { FireInput(smoke, \"turnon\"); // Add a wait handling here. Wait(7.0, WH_FREEZE_MAPNAME); // And if we want to be 100% sure, let's remake the handle @smoke = FindEntByName(\"reinforcement_smoke\"); FireInput(smoke, \"turnoff\"); } } } The only exception is the Player, it'll always be a valid entity after transition. There are several ways handling this: Wait(7.0, WH_ABORT_MAPNAME); -- This will cause the execution to abort if the map name doesn't match after waiting. Wait(7.0, WH_ABORT_LEVELCHANGE); -- The WH_ABORT_LEVELCHANGE one will cause the execution to abort on any kind of level change. Or... Wait(7.0, WH_FREEZE_MAPNAME); -- This will cause the execution to freeze until the map name matches it originally executed from. When you work with entities, just keep this in mind that after a level change some entities in the code execution might become invalid, so it's fine to just simply abort them to avoid any crashes.","title":"Delaying code executions"},{"location":"tutorials/gettingstarted/","text":"Getting started \uf0c1 Note This tutorial also applies to Catharsis Reborn Postal 3 (pre-ZOOM/ZOOM version) does not have AngelScript! (get Angel mod from here: ModDB ) Getting script files to load \uf0c1 Head over to ../p3/scripts/AngelScript/ and open !as_scripts.txt You'll see a bunch of files have already been included: // This number is looked for when loading save file, you can up this number everytime you make heavy changes to the codebase // If before and after numbers don't match, the Serializer will automatically abort when attempting to restore values // NOTE: This absolutely must be an integer! const int AS_MOD_VERSION = 0; #include \"engine.as\" #include \"npc.as\" #include \"player.as\" Typically here we only want to use #include and no other code here, but there's nothing stopping you from actually putting code in there, it just won't look nice! Start the game, load into a map, then alt TAB out \uf0c1 AngelScript can be recompiled while the game is running, you don't need to reload the game itself! (normally AngelScript will only compile once per game) Creating a working example from scratch \uf0c1 In the AngelScript folder where !as_scripts.txt is located create a file called example.as Then open !as_scripts.txt and include it like so: #include \"example.as\" If you want to put this file into a folder, you can also do that like so: #include \"myfolder/example.as\" Just remember if you want to include other files (inside example.as ) you will need to navigate back like so: // This would be \"../p3/scripts/AngelScript/utils.as\" #include \"../utils.as\" // This would be \"../p3/scripts/AngelScript/myfolder/tools.as\" #include \"tools.as\" open \"example.as\" \uf0c1 Now we'll add a very simple class that will only print console messages, the comments will explain everything: // If you want to take advantage of cache and script object functions, you need to // inherit from IPostal3Script, otherwise it won't work! class MyCustomClass : IPostal3Script { // A simple variable, this is what we'll refer to the entity // (from their viewpoint they are \"self\") CP3SObj@ self; // This can store numbers, crazy right? int num; // The constructor, this is where you can set up variables // This function is always the class name, don't also forget about the CP3SObj@ param! // Note: if the class will be both global and non-global then make sure to check obj is not null! MyCustomClass(CP3SObj@ obj) { //if (@obj != null) @self = obj; // Start at 0, better safe than sorry num = 0; } // We'll call this in Postal3Script, you can add parameters but P3S does not support this // you can still call this function in other functions if you wanted to! void VerySimpleFunction() { // This is the same as \"num = num + 1\" num++; // Note: If you aren't too familiar with Printf, here's this cheat sheet // int : %d // string : %s // float : %f // Break line : \\n // Using the wrong character might result in corrupted text or crash, always double check :) // Now we'll print this variable's value to the console Printf(\"VerySimpleFunction: %d\\n\", num); } } Now head back into the game and enter wj_angelscript_recompile If everything went smoothly then you should not see any ERROR messages. Debugging \uf0c1 Now that we have compiled the code we want to make sure it really works. Head back into the game and enter the following: wj_angelscript_exec MyCustomClass VerySimpleFunction This should have printed VerySimpleFunction: 1 to the console if everything went smoothly. Now if you spam this command the number should go higher and higher, that means it works just fine! Note wj_angelscript_exec will execute functions GLOBALLY Postal3Script \uf0c1 Now that we know we didn't mess up anything with copy and pasting, we'll modify the Player's AI to execute VerySimpleFunction() from AS every second. Head into the scripts folder and find ai_player.p3s Scroll down and look for xpt_OnPrimaryAttack Put this before IfAttr \"Timer:tPrimaryAttack > 0 Return 1\" : // target <class> <function> AngelScript \"Object:self MyCustomClass VerySimpleFunction\" It should look something like this: xpt_OnPrimaryAttack { actions { AngelScript \"Object:self MyCustomClass VerySimpleFunction\" IfAttr \"Timer:tPrimaryAttack > 0 Return 1\" Timer tPrimaryAttack,3 //IfAttr \"ea_ActiveWeapon >= 5 Block begin\" //ExecutePattern .xpt_SaveStatus //SetAttr \"ea_status sKILLER\" //Timer tKiller,20 //Block end //Brutal primary attacks IfAttr \"ea_armed == WPN_GRENADE ExecutePattern .xpt_OnBrutalAct\" IfAttr \"ea_armed == WPN_MOLOTOV ExecutePattern .xpt_OnBrutalAct\" IfAttr \"ea_armed == WPN_BEES ExecutePattern .xpt_OnBrutalAct\" //Wrong primary attacks IfAttr \"ea_armed == WPN_GAS ExecutePattern .xpt_OnWrongAct\" IfAttr \"ea_armed == WPN_SPRAY ExecutePattern .xpt_OnWrongAct\" IfAttr \"ea_armed == WPN_CATS ExecutePattern .xpt_OnWrongAct\" IfAttr \"ea_armed == WPN_CATNIP ExecutePattern .xpt_OnWrongAct\" IfAttr \"ea_armed == WPN_TASER ExecutePattern .xpt_OnWrongAct\" } } Recompile AngelScript with wj_angelscript_recompile and reload the level by entering reload Now everytime you shoot, the number should increase everytime. Object:self can always be replaced with GLOBAL , but then that class would be shared with other NPCs or Players, everytime they would shoot, the number would go up, they would not have their \"own\" number. You can tinker with this by doing similar experiments BUT with NPCs instead.","title":"Getting Started"},{"location":"tutorials/gettingstarted/#getting-started","text":"Note This tutorial also applies to Catharsis Reborn Postal 3 (pre-ZOOM/ZOOM version) does not have AngelScript! (get Angel mod from here: ModDB )","title":"Getting started"},{"location":"tutorials/gettingstarted/#getting-script-files-to-load","text":"Head over to ../p3/scripts/AngelScript/ and open !as_scripts.txt You'll see a bunch of files have already been included: // This number is looked for when loading save file, you can up this number everytime you make heavy changes to the codebase // If before and after numbers don't match, the Serializer will automatically abort when attempting to restore values // NOTE: This absolutely must be an integer! const int AS_MOD_VERSION = 0; #include \"engine.as\" #include \"npc.as\" #include \"player.as\" Typically here we only want to use #include and no other code here, but there's nothing stopping you from actually putting code in there, it just won't look nice!","title":"Getting script files to load"},{"location":"tutorials/gettingstarted/#start-the-game-load-into-a-map-then-alt-tab-out","text":"AngelScript can be recompiled while the game is running, you don't need to reload the game itself! (normally AngelScript will only compile once per game)","title":"Start the game, load into a map, then alt TAB out"},{"location":"tutorials/gettingstarted/#creating-a-working-example-from-scratch","text":"In the AngelScript folder where !as_scripts.txt is located create a file called example.as Then open !as_scripts.txt and include it like so: #include \"example.as\" If you want to put this file into a folder, you can also do that like so: #include \"myfolder/example.as\" Just remember if you want to include other files (inside example.as ) you will need to navigate back like so: // This would be \"../p3/scripts/AngelScript/utils.as\" #include \"../utils.as\" // This would be \"../p3/scripts/AngelScript/myfolder/tools.as\" #include \"tools.as\"","title":"Creating a working example from scratch"},{"location":"tutorials/gettingstarted/#open-exampleas","text":"Now we'll add a very simple class that will only print console messages, the comments will explain everything: // If you want to take advantage of cache and script object functions, you need to // inherit from IPostal3Script, otherwise it won't work! class MyCustomClass : IPostal3Script { // A simple variable, this is what we'll refer to the entity // (from their viewpoint they are \"self\") CP3SObj@ self; // This can store numbers, crazy right? int num; // The constructor, this is where you can set up variables // This function is always the class name, don't also forget about the CP3SObj@ param! // Note: if the class will be both global and non-global then make sure to check obj is not null! MyCustomClass(CP3SObj@ obj) { //if (@obj != null) @self = obj; // Start at 0, better safe than sorry num = 0; } // We'll call this in Postal3Script, you can add parameters but P3S does not support this // you can still call this function in other functions if you wanted to! void VerySimpleFunction() { // This is the same as \"num = num + 1\" num++; // Note: If you aren't too familiar with Printf, here's this cheat sheet // int : %d // string : %s // float : %f // Break line : \\n // Using the wrong character might result in corrupted text or crash, always double check :) // Now we'll print this variable's value to the console Printf(\"VerySimpleFunction: %d\\n\", num); } } Now head back into the game and enter wj_angelscript_recompile If everything went smoothly then you should not see any ERROR messages.","title":"open \"example.as\""},{"location":"tutorials/gettingstarted/#debugging","text":"Now that we have compiled the code we want to make sure it really works. Head back into the game and enter the following: wj_angelscript_exec MyCustomClass VerySimpleFunction This should have printed VerySimpleFunction: 1 to the console if everything went smoothly. Now if you spam this command the number should go higher and higher, that means it works just fine! Note wj_angelscript_exec will execute functions GLOBALLY","title":"Debugging"},{"location":"tutorials/gettingstarted/#postal3script","text":"Now that we know we didn't mess up anything with copy and pasting, we'll modify the Player's AI to execute VerySimpleFunction() from AS every second. Head into the scripts folder and find ai_player.p3s Scroll down and look for xpt_OnPrimaryAttack Put this before IfAttr \"Timer:tPrimaryAttack > 0 Return 1\" : // target <class> <function> AngelScript \"Object:self MyCustomClass VerySimpleFunction\" It should look something like this: xpt_OnPrimaryAttack { actions { AngelScript \"Object:self MyCustomClass VerySimpleFunction\" IfAttr \"Timer:tPrimaryAttack > 0 Return 1\" Timer tPrimaryAttack,3 //IfAttr \"ea_ActiveWeapon >= 5 Block begin\" //ExecutePattern .xpt_SaveStatus //SetAttr \"ea_status sKILLER\" //Timer tKiller,20 //Block end //Brutal primary attacks IfAttr \"ea_armed == WPN_GRENADE ExecutePattern .xpt_OnBrutalAct\" IfAttr \"ea_armed == WPN_MOLOTOV ExecutePattern .xpt_OnBrutalAct\" IfAttr \"ea_armed == WPN_BEES ExecutePattern .xpt_OnBrutalAct\" //Wrong primary attacks IfAttr \"ea_armed == WPN_GAS ExecutePattern .xpt_OnWrongAct\" IfAttr \"ea_armed == WPN_SPRAY ExecutePattern .xpt_OnWrongAct\" IfAttr \"ea_armed == WPN_CATS ExecutePattern .xpt_OnWrongAct\" IfAttr \"ea_armed == WPN_CATNIP ExecutePattern .xpt_OnWrongAct\" IfAttr \"ea_armed == WPN_TASER ExecutePattern .xpt_OnWrongAct\" } } Recompile AngelScript with wj_angelscript_recompile and reload the level by entering reload Now everytime you shoot, the number should increase everytime. Object:self can always be replaced with GLOBAL , but then that class would be shared with other NPCs or Players, everytime they would shoot, the number would go up, they would not have their \"own\" number. You can tinker with this by doing similar experiments BUT with NPCs instead.","title":"Postal3Script"},{"location":"tutorials/repeating/","text":"Repeating \uf0c1 Postal3Script has a function called Repeat where you can repeat actions over and over again. This is also possible in AngelScript thanks to Wait function. Here's how you can do an infinite repeat as an example: class Tut : IPostal3Script { // This has to be executed once! (in it's own context) void CheckPlayer() { CP3SObj@ pPlayer = GetPlayer(); // For some reason it's null if (pPlayer == null) return; string behavior = pPlayer.GetBehavior(); behavior.toLower(); // The Player is dead (the behavior's name changes when Dude dies in CR) if (behavior != \"bh_player\") return; // This checks if the Player's health is under 50, and if yes it'll set it back to 50. if (pPlayer.GetAttr(\"ea_health\") < 50) pPlayer.SetAttr(\"ea_health\", 50); Wait(3.0); // Recall the function CheckPlayer(); } }","title":"Repeating"},{"location":"tutorials/repeating/#repeating","text":"Postal3Script has a function called Repeat where you can repeat actions over and over again. This is also possible in AngelScript thanks to Wait function. Here's how you can do an infinite repeat as an example: class Tut : IPostal3Script { // This has to be executed once! (in it's own context) void CheckPlayer() { CP3SObj@ pPlayer = GetPlayer(); // For some reason it's null if (pPlayer == null) return; string behavior = pPlayer.GetBehavior(); behavior.toLower(); // The Player is dead (the behavior's name changes when Dude dies in CR) if (behavior != \"bh_player\") return; // This checks if the Player's health is under 50, and if yes it'll set it back to 50. if (pPlayer.GetAttr(\"ea_health\") < 50) pPlayer.SetAttr(\"ea_health\", 50); Wait(3.0); // Recall the function CheckPlayer(); } }","title":"Repeating"},{"location":"tutorials/scriptclass/","text":"Getting Script Classes \uf0c1 In AngelScript you can access Postal3Script attributes from one way to another, but you can also do the same thing with AngelScript classes. However there are 3 downsides: The script class must be cached, otherwise it won't work Casting must be done manually, because AngelScript cannot do it automatically The only way to detect if it's cached (or wrong) is to check if the script object is null or not We'll use GetScriptObj for this. Example: (from PC, modified) class PCMonitor : IPostal3Script { CP3SObj@ self; int iMaxSkins; } class PC : IPostal3Script { // Dummy void Init(){} CP3SObj@ self; // This must be declared as a handle! PCMonitor@ monitor; PC(CP3SObj@ obj) { @self = @obj; // Get the closest monitor to us after everything's loaded engine.DelayedExecution(0, \"PC\", \"GetMonitor\", self); } void GetMonitor() { CP3SObj@ mon = null; array<CP3SObj@> aNPC = engine.GetArrayOfEntitiesRadius(self, 96); for (uint i = 0; i < aNPC.length(); i++) { if ( @aNPC[i] == null ) continue; if ( @aNPC[i] == @self ) continue; if ( aNPC[i].GetBaseEntity().GetClassName() != \"cr_prop_interactable\" ) continue; if ( aNPC[i].GetManner() != \"PCMonitor\" ) continue; // We got ourselves a monitor, break! @mon = @aNPC[i]; break; } // Failed to get a monitor if (@mon == null) return; // We'll now attempt getting the script class to the monitor we got earlier @monitor = cast<PCMonitor@>(GetScriptObj(\"PCMonitor\", mon)); // Class wasn't cached for some reason! // (but it's also generally a good idea to do null checking) if (@monitor == null) return; // We can now access the variables... like this Printf(\"Monitor Max Skins: %d\\n\", monitor.iMaxSkins); // even all of it's handle objects if (@monitor.self != null) Printf(\"Monitor Faction: %s\\n\", monitor.self.GetFaction()); } }","title":"Getting Script Classes"},{"location":"tutorials/scriptclass/#getting-script-classes","text":"In AngelScript you can access Postal3Script attributes from one way to another, but you can also do the same thing with AngelScript classes. However there are 3 downsides: The script class must be cached, otherwise it won't work Casting must be done manually, because AngelScript cannot do it automatically The only way to detect if it's cached (or wrong) is to check if the script object is null or not We'll use GetScriptObj for this. Example: (from PC, modified) class PCMonitor : IPostal3Script { CP3SObj@ self; int iMaxSkins; } class PC : IPostal3Script { // Dummy void Init(){} CP3SObj@ self; // This must be declared as a handle! PCMonitor@ monitor; PC(CP3SObj@ obj) { @self = @obj; // Get the closest monitor to us after everything's loaded engine.DelayedExecution(0, \"PC\", \"GetMonitor\", self); } void GetMonitor() { CP3SObj@ mon = null; array<CP3SObj@> aNPC = engine.GetArrayOfEntitiesRadius(self, 96); for (uint i = 0; i < aNPC.length(); i++) { if ( @aNPC[i] == null ) continue; if ( @aNPC[i] == @self ) continue; if ( aNPC[i].GetBaseEntity().GetClassName() != \"cr_prop_interactable\" ) continue; if ( aNPC[i].GetManner() != \"PCMonitor\" ) continue; // We got ourselves a monitor, break! @mon = @aNPC[i]; break; } // Failed to get a monitor if (@mon == null) return; // We'll now attempt getting the script class to the monitor we got earlier @monitor = cast<PCMonitor@>(GetScriptObj(\"PCMonitor\", mon)); // Class wasn't cached for some reason! // (but it's also generally a good idea to do null checking) if (@monitor == null) return; // We can now access the variables... like this Printf(\"Monitor Max Skins: %d\\n\", monitor.iMaxSkins); // even all of it's handle objects if (@monitor.self != null) Printf(\"Monitor Faction: %s\\n\", monitor.self.GetFaction()); } }","title":"Getting Script Classes"}]}